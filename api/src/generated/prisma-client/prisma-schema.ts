// Code generated by Prisma (prisma@1.32.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCarromBoardScore {
  count: Int!
}

type AggregateCarromBoardScoreActivity {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateChessScore {
  count: Int!
}

type AggregateCounterStrikeFScore {
  count: Int!
}

type AggregateCounterStrikeScoreSet {
  count: Int!
}

type AggregateCounterStrikeScoreSetActivity {
  count: Int!
}

type AggregateDotaScore {
  count: Int!
}

type AggregateDotaScoreActivity {
  count: Int!
}

type AggregateEmployee {
  count: Int!
}

type AggregateFixture {
  count: Int!
}

type AggregateFootballScore {
  count: Int!
}

type AggregateFootballScoreActivity {
  count: Int!
}

type AggregateGame {
  count: Int!
}

type AggregateRound {
  count: Int!
}

type AggregateStatus {
  count: Int!
}

type AggregateSubTournament {
  count: Int!
}

type AggregateSubTournamentPlayer {
  count: Int!
}

type AggregateTableTennisScore {
  count: Int!
}

type AggregateTableTennisScoreActivity {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateTeamPlayer {
  count: Int!
}

type AggregateTournament {
  count: Int!
}

type AggregateUserAccount {
  count: Int!
}

type AggregateUserAccountToken {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type CarromBoardScore {
  id: ID!
  fixture: Fixture!
  homeTeamScore: Int
  awayTeamScore: Int
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CarromBoardScoreActivity {
  id: ID!
  fixture: Fixture!
  team: Team!
  points: Int!
  order: Int!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CarromBoardScoreActivityConnection {
  pageInfo: PageInfo!
  edges: [CarromBoardScoreActivityEdge]!
  aggregate: AggregateCarromBoardScoreActivity!
}

input CarromBoardScoreActivityCreateInput {
  fixture: FixtureCreateOneInput!
  team: TeamCreateOneInput!
  points: Int!
  order: Int!
  updatedBy: UserAccountCreateOneInput!
}

type CarromBoardScoreActivityEdge {
  node: CarromBoardScoreActivity!
  cursor: String!
}

enum CarromBoardScoreActivityOrderByInput {
  id_ASC
  id_DESC
  points_ASC
  points_DESC
  order_ASC
  order_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CarromBoardScoreActivityPreviousValues {
  id: ID!
  points: Int!
  order: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CarromBoardScoreActivitySubscriptionPayload {
  mutation: MutationType!
  node: CarromBoardScoreActivity
  updatedFields: [String!]
  previousValues: CarromBoardScoreActivityPreviousValues
}

input CarromBoardScoreActivitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CarromBoardScoreActivityWhereInput
  AND: [CarromBoardScoreActivitySubscriptionWhereInput!]
  OR: [CarromBoardScoreActivitySubscriptionWhereInput!]
  NOT: [CarromBoardScoreActivitySubscriptionWhereInput!]
}

input CarromBoardScoreActivityUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  team: TeamUpdateOneRequiredInput
  points: Int
  order: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CarromBoardScoreActivityUpdateManyMutationInput {
  points: Int
  order: Int
}

input CarromBoardScoreActivityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  team: TeamWhereInput
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CarromBoardScoreActivityWhereInput!]
  OR: [CarromBoardScoreActivityWhereInput!]
  NOT: [CarromBoardScoreActivityWhereInput!]
}

input CarromBoardScoreActivityWhereUniqueInput {
  id: ID
}

type CarromBoardScoreConnection {
  pageInfo: PageInfo!
  edges: [CarromBoardScoreEdge]!
  aggregate: AggregateCarromBoardScore!
}

input CarromBoardScoreCreateInput {
  fixture: FixtureCreateOneInput!
  homeTeamScore: Int
  awayTeamScore: Int
  updatedBy: UserAccountCreateOneInput!
}

type CarromBoardScoreEdge {
  node: CarromBoardScore!
  cursor: String!
}

enum CarromBoardScoreOrderByInput {
  id_ASC
  id_DESC
  homeTeamScore_ASC
  homeTeamScore_DESC
  awayTeamScore_ASC
  awayTeamScore_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CarromBoardScorePreviousValues {
  id: ID!
  homeTeamScore: Int
  awayTeamScore: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CarromBoardScoreSubscriptionPayload {
  mutation: MutationType!
  node: CarromBoardScore
  updatedFields: [String!]
  previousValues: CarromBoardScorePreviousValues
}

input CarromBoardScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CarromBoardScoreWhereInput
  AND: [CarromBoardScoreSubscriptionWhereInput!]
  OR: [CarromBoardScoreSubscriptionWhereInput!]
  NOT: [CarromBoardScoreSubscriptionWhereInput!]
}

input CarromBoardScoreUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  homeTeamScore: Int
  awayTeamScore: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CarromBoardScoreUpdateManyMutationInput {
  homeTeamScore: Int
  awayTeamScore: Int
}

input CarromBoardScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  homeTeamScore: Int
  homeTeamScore_not: Int
  homeTeamScore_in: [Int!]
  homeTeamScore_not_in: [Int!]
  homeTeamScore_lt: Int
  homeTeamScore_lte: Int
  homeTeamScore_gt: Int
  homeTeamScore_gte: Int
  awayTeamScore: Int
  awayTeamScore_not: Int
  awayTeamScore_in: [Int!]
  awayTeamScore_not_in: [Int!]
  awayTeamScore_lt: Int
  awayTeamScore_lte: Int
  awayTeamScore_gt: Int
  awayTeamScore_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CarromBoardScoreWhereInput!]
  OR: [CarromBoardScoreWhereInput!]
  NOT: [CarromBoardScoreWhereInput!]
}

input CarromBoardScoreWhereUniqueInput {
  id: ID
}

type Category {
  id: ID!
  name: String!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  name: String!
  updatedBy: UserAccountCreateOneInput!
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  name: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CategoryUpdateInput {
  name: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneRequiredInput {
  create: CategoryCreateInput
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

type ChessScore {
  id: ID!
  fixture: Fixture!
  winnerTeam: Team
  winningMethod: ChessWinningMethod
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChessScoreConnection {
  pageInfo: PageInfo!
  edges: [ChessScoreEdge]!
  aggregate: AggregateChessScore!
}

input ChessScoreCreateInput {
  fixture: FixtureCreateOneInput!
  winnerTeam: TeamCreateOneInput
  winningMethod: ChessWinningMethod
  updatedBy: UserAccountCreateOneInput!
}

type ChessScoreEdge {
  node: ChessScore!
  cursor: String!
}

enum ChessScoreOrderByInput {
  id_ASC
  id_DESC
  winningMethod_ASC
  winningMethod_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ChessScorePreviousValues {
  id: ID!
  winningMethod: ChessWinningMethod
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChessScoreSubscriptionPayload {
  mutation: MutationType!
  node: ChessScore
  updatedFields: [String!]
  previousValues: ChessScorePreviousValues
}

input ChessScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChessScoreWhereInput
  AND: [ChessScoreSubscriptionWhereInput!]
  OR: [ChessScoreSubscriptionWhereInput!]
  NOT: [ChessScoreSubscriptionWhereInput!]
}

input ChessScoreUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  winnerTeam: TeamUpdateOneInput
  winningMethod: ChessWinningMethod
  updatedBy: UserAccountUpdateOneRequiredInput
}

input ChessScoreUpdateManyMutationInput {
  winningMethod: ChessWinningMethod
}

input ChessScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  winnerTeam: TeamWhereInput
  winningMethod: ChessWinningMethod
  winningMethod_not: ChessWinningMethod
  winningMethod_in: [ChessWinningMethod!]
  winningMethod_not_in: [ChessWinningMethod!]
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ChessScoreWhereInput!]
  OR: [ChessScoreWhereInput!]
  NOT: [ChessScoreWhereInput!]
}

input ChessScoreWhereUniqueInput {
  id: ID
}

enum ChessWinningMethod {
  TIME
  CHECKMATE
}

type CounterStrikeFScore {
  id: ID!
  fixture: Fixture!
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CounterStrikeFScoreConnection {
  pageInfo: PageInfo!
  edges: [CounterStrikeFScoreEdge]!
  aggregate: AggregateCounterStrikeFScore!
}

input CounterStrikeFScoreCreateInput {
  fixture: FixtureCreateOneInput!
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int!
  updatedBy: UserAccountCreateOneInput!
}

type CounterStrikeFScoreEdge {
  node: CounterStrikeFScore!
  cursor: String!
}

enum CounterStrikeFScoreOrderByInput {
  id_ASC
  id_DESC
  homeTeamScore_ASC
  homeTeamScore_DESC
  awayTeamScore_ASC
  awayTeamScore_DESC
  setsCount_ASC
  setsCount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CounterStrikeFScorePreviousValues {
  id: ID!
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CounterStrikeFScoreSubscriptionPayload {
  mutation: MutationType!
  node: CounterStrikeFScore
  updatedFields: [String!]
  previousValues: CounterStrikeFScorePreviousValues
}

input CounterStrikeFScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CounterStrikeFScoreWhereInput
  AND: [CounterStrikeFScoreSubscriptionWhereInput!]
  OR: [CounterStrikeFScoreSubscriptionWhereInput!]
  NOT: [CounterStrikeFScoreSubscriptionWhereInput!]
}

input CounterStrikeFScoreUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CounterStrikeFScoreUpdateManyMutationInput {
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int
}

input CounterStrikeFScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  homeTeamScore: Int
  homeTeamScore_not: Int
  homeTeamScore_in: [Int!]
  homeTeamScore_not_in: [Int!]
  homeTeamScore_lt: Int
  homeTeamScore_lte: Int
  homeTeamScore_gt: Int
  homeTeamScore_gte: Int
  awayTeamScore: Int
  awayTeamScore_not: Int
  awayTeamScore_in: [Int!]
  awayTeamScore_not_in: [Int!]
  awayTeamScore_lt: Int
  awayTeamScore_lte: Int
  awayTeamScore_gt: Int
  awayTeamScore_gte: Int
  setsCount: Int
  setsCount_not: Int
  setsCount_in: [Int!]
  setsCount_not_in: [Int!]
  setsCount_lt: Int
  setsCount_lte: Int
  setsCount_gt: Int
  setsCount_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CounterStrikeFScoreWhereInput!]
  OR: [CounterStrikeFScoreWhereInput!]
  NOT: [CounterStrikeFScoreWhereInput!]
}

input CounterStrikeFScoreWhereUniqueInput {
  id: ID
}

type CounterStrikeScoreSet {
  id: ID!
  fixture: Fixture!
  set: Int!
  homeTeamScore: Int!
  awayTeamScore: Int!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CounterStrikeScoreSetActivity {
  id: ID!
  set: CounterStrikeScoreSet!
  teamPlayer: TeamPlayer!
  kills: Int!
  deaths: Int!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CounterStrikeScoreSetActivityConnection {
  pageInfo: PageInfo!
  edges: [CounterStrikeScoreSetActivityEdge]!
  aggregate: AggregateCounterStrikeScoreSetActivity!
}

input CounterStrikeScoreSetActivityCreateInput {
  set: CounterStrikeScoreSetCreateOneInput!
  teamPlayer: TeamPlayerCreateOneInput!
  kills: Int!
  deaths: Int!
  updatedBy: UserAccountCreateOneInput!
}

type CounterStrikeScoreSetActivityEdge {
  node: CounterStrikeScoreSetActivity!
  cursor: String!
}

enum CounterStrikeScoreSetActivityOrderByInput {
  id_ASC
  id_DESC
  kills_ASC
  kills_DESC
  deaths_ASC
  deaths_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CounterStrikeScoreSetActivityPreviousValues {
  id: ID!
  kills: Int!
  deaths: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CounterStrikeScoreSetActivitySubscriptionPayload {
  mutation: MutationType!
  node: CounterStrikeScoreSetActivity
  updatedFields: [String!]
  previousValues: CounterStrikeScoreSetActivityPreviousValues
}

input CounterStrikeScoreSetActivitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CounterStrikeScoreSetActivityWhereInput
  AND: [CounterStrikeScoreSetActivitySubscriptionWhereInput!]
  OR: [CounterStrikeScoreSetActivitySubscriptionWhereInput!]
  NOT: [CounterStrikeScoreSetActivitySubscriptionWhereInput!]
}

input CounterStrikeScoreSetActivityUpdateInput {
  set: CounterStrikeScoreSetUpdateOneRequiredInput
  teamPlayer: TeamPlayerUpdateOneRequiredInput
  kills: Int
  deaths: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CounterStrikeScoreSetActivityUpdateManyMutationInput {
  kills: Int
  deaths: Int
}

input CounterStrikeScoreSetActivityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  set: CounterStrikeScoreSetWhereInput
  teamPlayer: TeamPlayerWhereInput
  kills: Int
  kills_not: Int
  kills_in: [Int!]
  kills_not_in: [Int!]
  kills_lt: Int
  kills_lte: Int
  kills_gt: Int
  kills_gte: Int
  deaths: Int
  deaths_not: Int
  deaths_in: [Int!]
  deaths_not_in: [Int!]
  deaths_lt: Int
  deaths_lte: Int
  deaths_gt: Int
  deaths_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CounterStrikeScoreSetActivityWhereInput!]
  OR: [CounterStrikeScoreSetActivityWhereInput!]
  NOT: [CounterStrikeScoreSetActivityWhereInput!]
}

input CounterStrikeScoreSetActivityWhereUniqueInput {
  id: ID
}

type CounterStrikeScoreSetConnection {
  pageInfo: PageInfo!
  edges: [CounterStrikeScoreSetEdge]!
  aggregate: AggregateCounterStrikeScoreSet!
}

input CounterStrikeScoreSetCreateInput {
  fixture: FixtureCreateOneInput!
  set: Int!
  homeTeamScore: Int!
  awayTeamScore: Int!
  updatedBy: UserAccountCreateOneInput!
}

input CounterStrikeScoreSetCreateOneInput {
  create: CounterStrikeScoreSetCreateInput
  connect: CounterStrikeScoreSetWhereUniqueInput
}

type CounterStrikeScoreSetEdge {
  node: CounterStrikeScoreSet!
  cursor: String!
}

enum CounterStrikeScoreSetOrderByInput {
  id_ASC
  id_DESC
  set_ASC
  set_DESC
  homeTeamScore_ASC
  homeTeamScore_DESC
  awayTeamScore_ASC
  awayTeamScore_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CounterStrikeScoreSetPreviousValues {
  id: ID!
  set: Int!
  homeTeamScore: Int!
  awayTeamScore: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CounterStrikeScoreSetSubscriptionPayload {
  mutation: MutationType!
  node: CounterStrikeScoreSet
  updatedFields: [String!]
  previousValues: CounterStrikeScoreSetPreviousValues
}

input CounterStrikeScoreSetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CounterStrikeScoreSetWhereInput
  AND: [CounterStrikeScoreSetSubscriptionWhereInput!]
  OR: [CounterStrikeScoreSetSubscriptionWhereInput!]
  NOT: [CounterStrikeScoreSetSubscriptionWhereInput!]
}

input CounterStrikeScoreSetUpdateDataInput {
  fixture: FixtureUpdateOneRequiredInput
  set: Int
  homeTeamScore: Int
  awayTeamScore: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CounterStrikeScoreSetUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  set: Int
  homeTeamScore: Int
  awayTeamScore: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input CounterStrikeScoreSetUpdateManyMutationInput {
  set: Int
  homeTeamScore: Int
  awayTeamScore: Int
}

input CounterStrikeScoreSetUpdateOneRequiredInput {
  create: CounterStrikeScoreSetCreateInput
  update: CounterStrikeScoreSetUpdateDataInput
  upsert: CounterStrikeScoreSetUpsertNestedInput
  connect: CounterStrikeScoreSetWhereUniqueInput
}

input CounterStrikeScoreSetUpsertNestedInput {
  update: CounterStrikeScoreSetUpdateDataInput!
  create: CounterStrikeScoreSetCreateInput!
}

input CounterStrikeScoreSetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  set: Int
  set_not: Int
  set_in: [Int!]
  set_not_in: [Int!]
  set_lt: Int
  set_lte: Int
  set_gt: Int
  set_gte: Int
  homeTeamScore: Int
  homeTeamScore_not: Int
  homeTeamScore_in: [Int!]
  homeTeamScore_not_in: [Int!]
  homeTeamScore_lt: Int
  homeTeamScore_lte: Int
  homeTeamScore_gt: Int
  homeTeamScore_gte: Int
  awayTeamScore: Int
  awayTeamScore_not: Int
  awayTeamScore_in: [Int!]
  awayTeamScore_not_in: [Int!]
  awayTeamScore_lt: Int
  awayTeamScore_lte: Int
  awayTeamScore_gt: Int
  awayTeamScore_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CounterStrikeScoreSetWhereInput!]
  OR: [CounterStrikeScoreSetWhereInput!]
  NOT: [CounterStrikeScoreSetWhereInput!]
}

input CounterStrikeScoreSetWhereUniqueInput {
  id: ID
}

scalar DateTime

type DotaScore {
  id: ID!
  fixture: Fixture!
  setsCount: Int!
  winnerTeam: Team
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DotaScoreActivity {
  id: ID!
  fixture: Fixture!
  set: Int!
  winnerTeam: Team!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DotaScoreActivityConnection {
  pageInfo: PageInfo!
  edges: [DotaScoreActivityEdge]!
  aggregate: AggregateDotaScoreActivity!
}

input DotaScoreActivityCreateInput {
  fixture: FixtureCreateOneInput!
  set: Int!
  winnerTeam: TeamCreateOneInput!
  updatedBy: UserAccountCreateOneInput!
}

type DotaScoreActivityEdge {
  node: DotaScoreActivity!
  cursor: String!
}

enum DotaScoreActivityOrderByInput {
  id_ASC
  id_DESC
  set_ASC
  set_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DotaScoreActivityPreviousValues {
  id: ID!
  set: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DotaScoreActivitySubscriptionPayload {
  mutation: MutationType!
  node: DotaScoreActivity
  updatedFields: [String!]
  previousValues: DotaScoreActivityPreviousValues
}

input DotaScoreActivitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DotaScoreActivityWhereInput
  AND: [DotaScoreActivitySubscriptionWhereInput!]
  OR: [DotaScoreActivitySubscriptionWhereInput!]
  NOT: [DotaScoreActivitySubscriptionWhereInput!]
}

input DotaScoreActivityUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  set: Int
  winnerTeam: TeamUpdateOneRequiredInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input DotaScoreActivityUpdateManyMutationInput {
  set: Int
}

input DotaScoreActivityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  set: Int
  set_not: Int
  set_in: [Int!]
  set_not_in: [Int!]
  set_lt: Int
  set_lte: Int
  set_gt: Int
  set_gte: Int
  winnerTeam: TeamWhereInput
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DotaScoreActivityWhereInput!]
  OR: [DotaScoreActivityWhereInput!]
  NOT: [DotaScoreActivityWhereInput!]
}

input DotaScoreActivityWhereUniqueInput {
  id: ID
}

type DotaScoreConnection {
  pageInfo: PageInfo!
  edges: [DotaScoreEdge]!
  aggregate: AggregateDotaScore!
}

input DotaScoreCreateInput {
  fixture: FixtureCreateOneInput!
  setsCount: Int!
  winnerTeam: TeamCreateOneInput
  updatedBy: UserAccountCreateOneInput!
}

type DotaScoreEdge {
  node: DotaScore!
  cursor: String!
}

enum DotaScoreOrderByInput {
  id_ASC
  id_DESC
  setsCount_ASC
  setsCount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DotaScorePreviousValues {
  id: ID!
  setsCount: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DotaScoreSubscriptionPayload {
  mutation: MutationType!
  node: DotaScore
  updatedFields: [String!]
  previousValues: DotaScorePreviousValues
}

input DotaScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DotaScoreWhereInput
  AND: [DotaScoreSubscriptionWhereInput!]
  OR: [DotaScoreSubscriptionWhereInput!]
  NOT: [DotaScoreSubscriptionWhereInput!]
}

input DotaScoreUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  setsCount: Int
  winnerTeam: TeamUpdateOneInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input DotaScoreUpdateManyMutationInput {
  setsCount: Int
}

input DotaScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  setsCount: Int
  setsCount_not: Int
  setsCount_in: [Int!]
  setsCount_not_in: [Int!]
  setsCount_lt: Int
  setsCount_lte: Int
  setsCount_gt: Int
  setsCount_gte: Int
  winnerTeam: TeamWhereInput
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DotaScoreWhereInput!]
  OR: [DotaScoreWhereInput!]
  NOT: [DotaScoreWhereInput!]
}

input DotaScoreWhereUniqueInput {
  id: ID
}

type Employee {
  id: ID!
  firstName: String!
  middleName: String
  lastName: String!
  profilePictureUrl: String
  lmsEmpId: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EmployeeConnection {
  pageInfo: PageInfo!
  edges: [EmployeeEdge]!
  aggregate: AggregateEmployee!
}

input EmployeeCreateInput {
  firstName: String!
  middleName: String
  lastName: String!
  profilePictureUrl: String
  lmsEmpId: Int
}

input EmployeeCreateOneInput {
  create: EmployeeCreateInput
  connect: EmployeeWhereUniqueInput
}

type EmployeeEdge {
  node: Employee!
  cursor: String!
}

enum EmployeeOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  middleName_ASC
  middleName_DESC
  lastName_ASC
  lastName_DESC
  profilePictureUrl_ASC
  profilePictureUrl_DESC
  lmsEmpId_ASC
  lmsEmpId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EmployeePreviousValues {
  id: ID!
  firstName: String!
  middleName: String
  lastName: String!
  profilePictureUrl: String
  lmsEmpId: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EmployeeSubscriptionPayload {
  mutation: MutationType!
  node: Employee
  updatedFields: [String!]
  previousValues: EmployeePreviousValues
}

input EmployeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeeWhereInput
  AND: [EmployeeSubscriptionWhereInput!]
  OR: [EmployeeSubscriptionWhereInput!]
  NOT: [EmployeeSubscriptionWhereInput!]
}

input EmployeeUpdateDataInput {
  firstName: String
  middleName: String
  lastName: String
  profilePictureUrl: String
  lmsEmpId: Int
}

input EmployeeUpdateInput {
  firstName: String
  middleName: String
  lastName: String
  profilePictureUrl: String
  lmsEmpId: Int
}

input EmployeeUpdateManyMutationInput {
  firstName: String
  middleName: String
  lastName: String
  profilePictureUrl: String
  lmsEmpId: Int
}

input EmployeeUpdateOneRequiredInput {
  create: EmployeeCreateInput
  update: EmployeeUpdateDataInput
  upsert: EmployeeUpsertNestedInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpsertNestedInput {
  update: EmployeeUpdateDataInput!
  create: EmployeeCreateInput!
}

input EmployeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  middleName: String
  middleName_not: String
  middleName_in: [String!]
  middleName_not_in: [String!]
  middleName_lt: String
  middleName_lte: String
  middleName_gt: String
  middleName_gte: String
  middleName_contains: String
  middleName_not_contains: String
  middleName_starts_with: String
  middleName_not_starts_with: String
  middleName_ends_with: String
  middleName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  profilePictureUrl: String
  profilePictureUrl_not: String
  profilePictureUrl_in: [String!]
  profilePictureUrl_not_in: [String!]
  profilePictureUrl_lt: String
  profilePictureUrl_lte: String
  profilePictureUrl_gt: String
  profilePictureUrl_gte: String
  profilePictureUrl_contains: String
  profilePictureUrl_not_contains: String
  profilePictureUrl_starts_with: String
  profilePictureUrl_not_starts_with: String
  profilePictureUrl_ends_with: String
  profilePictureUrl_not_ends_with: String
  lmsEmpId: Int
  lmsEmpId_not: Int
  lmsEmpId_in: [Int!]
  lmsEmpId_not_in: [Int!]
  lmsEmpId_lt: Int
  lmsEmpId_lte: Int
  lmsEmpId_gt: Int
  lmsEmpId_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
}

input EmployeeWhereUniqueInput {
  id: ID
}

type Fixture {
  id: ID!
  subTournament: SubTournament!
  status: Status!
  dateTime: DateTime
  homeTeam: Team
  awayTeam: Team
  round: Round!
  homeTeamParentFixture: Fixture
  awayTeamParentFixture: Fixture
  images: [String!]!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FixtureConnection {
  pageInfo: PageInfo!
  edges: [FixtureEdge]!
  aggregate: AggregateFixture!
}

input FixtureCreateimagesInput {
  set: [String!]
}

input FixtureCreateInput {
  subTournament: SubTournamentCreateOneInput!
  status: StatusCreateOneInput!
  dateTime: DateTime
  homeTeam: TeamCreateOneInput
  awayTeam: TeamCreateOneInput
  round: RoundCreateOneInput!
  homeTeamParentFixture: FixtureCreateOneWithoutHomeTeamParentFixtureInput
  awayTeamParentFixture: FixtureCreateOneWithoutAwayTeamParentFixtureInput
  images: FixtureCreateimagesInput
  updatedBy: UserAccountCreateOneInput!
}

input FixtureCreateOneInput {
  create: FixtureCreateInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateOneWithoutAwayTeamParentFixtureInput {
  create: FixtureCreateWithoutAwayTeamParentFixtureInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateOneWithoutHomeTeamParentFixtureInput {
  create: FixtureCreateWithoutHomeTeamParentFixtureInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateWithoutAwayTeamParentFixtureInput {
  subTournament: SubTournamentCreateOneInput!
  status: StatusCreateOneInput!
  dateTime: DateTime
  homeTeam: TeamCreateOneInput
  awayTeam: TeamCreateOneInput
  round: RoundCreateOneInput!
  homeTeamParentFixture: FixtureCreateOneWithoutHomeTeamParentFixtureInput
  images: FixtureCreateimagesInput
  updatedBy: UserAccountCreateOneInput!
}

input FixtureCreateWithoutHomeTeamParentFixtureInput {
  subTournament: SubTournamentCreateOneInput!
  status: StatusCreateOneInput!
  dateTime: DateTime
  homeTeam: TeamCreateOneInput
  awayTeam: TeamCreateOneInput
  round: RoundCreateOneInput!
  awayTeamParentFixture: FixtureCreateOneWithoutAwayTeamParentFixtureInput
  images: FixtureCreateimagesInput
  updatedBy: UserAccountCreateOneInput!
}

type FixtureEdge {
  node: Fixture!
  cursor: String!
}

enum FixtureOrderByInput {
  id_ASC
  id_DESC
  dateTime_ASC
  dateTime_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FixturePreviousValues {
  id: ID!
  dateTime: DateTime
  images: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FixtureSubscriptionPayload {
  mutation: MutationType!
  node: Fixture
  updatedFields: [String!]
  previousValues: FixturePreviousValues
}

input FixtureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FixtureWhereInput
  AND: [FixtureSubscriptionWhereInput!]
  OR: [FixtureSubscriptionWhereInput!]
  NOT: [FixtureSubscriptionWhereInput!]
}

input FixtureUpdateDataInput {
  subTournament: SubTournamentUpdateOneRequiredInput
  status: StatusUpdateOneRequiredInput
  dateTime: DateTime
  homeTeam: TeamUpdateOneInput
  awayTeam: TeamUpdateOneInput
  round: RoundUpdateOneRequiredInput
  homeTeamParentFixture: FixtureUpdateOneWithoutHomeTeamParentFixtureInput
  awayTeamParentFixture: FixtureUpdateOneWithoutAwayTeamParentFixtureInput
  images: FixtureUpdateimagesInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input FixtureUpdateimagesInput {
  set: [String!]
}

input FixtureUpdateInput {
  subTournament: SubTournamentUpdateOneRequiredInput
  status: StatusUpdateOneRequiredInput
  dateTime: DateTime
  homeTeam: TeamUpdateOneInput
  awayTeam: TeamUpdateOneInput
  round: RoundUpdateOneRequiredInput
  homeTeamParentFixture: FixtureUpdateOneWithoutHomeTeamParentFixtureInput
  awayTeamParentFixture: FixtureUpdateOneWithoutAwayTeamParentFixtureInput
  images: FixtureUpdateimagesInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input FixtureUpdateManyMutationInput {
  dateTime: DateTime
  images: FixtureUpdateimagesInput
}

input FixtureUpdateOneRequiredInput {
  create: FixtureCreateInput
  update: FixtureUpdateDataInput
  upsert: FixtureUpsertNestedInput
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateOneWithoutAwayTeamParentFixtureInput {
  create: FixtureCreateWithoutAwayTeamParentFixtureInput
  update: FixtureUpdateWithoutAwayTeamParentFixtureDataInput
  upsert: FixtureUpsertWithoutAwayTeamParentFixtureInput
  delete: Boolean
  disconnect: Boolean
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateOneWithoutHomeTeamParentFixtureInput {
  create: FixtureCreateWithoutHomeTeamParentFixtureInput
  update: FixtureUpdateWithoutHomeTeamParentFixtureDataInput
  upsert: FixtureUpsertWithoutHomeTeamParentFixtureInput
  delete: Boolean
  disconnect: Boolean
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateWithoutAwayTeamParentFixtureDataInput {
  subTournament: SubTournamentUpdateOneRequiredInput
  status: StatusUpdateOneRequiredInput
  dateTime: DateTime
  homeTeam: TeamUpdateOneInput
  awayTeam: TeamUpdateOneInput
  round: RoundUpdateOneRequiredInput
  homeTeamParentFixture: FixtureUpdateOneWithoutHomeTeamParentFixtureInput
  images: FixtureUpdateimagesInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input FixtureUpdateWithoutHomeTeamParentFixtureDataInput {
  subTournament: SubTournamentUpdateOneRequiredInput
  status: StatusUpdateOneRequiredInput
  dateTime: DateTime
  homeTeam: TeamUpdateOneInput
  awayTeam: TeamUpdateOneInput
  round: RoundUpdateOneRequiredInput
  awayTeamParentFixture: FixtureUpdateOneWithoutAwayTeamParentFixtureInput
  images: FixtureUpdateimagesInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input FixtureUpsertNestedInput {
  update: FixtureUpdateDataInput!
  create: FixtureCreateInput!
}

input FixtureUpsertWithoutAwayTeamParentFixtureInput {
  update: FixtureUpdateWithoutAwayTeamParentFixtureDataInput!
  create: FixtureCreateWithoutAwayTeamParentFixtureInput!
}

input FixtureUpsertWithoutHomeTeamParentFixtureInput {
  update: FixtureUpdateWithoutHomeTeamParentFixtureDataInput!
  create: FixtureCreateWithoutHomeTeamParentFixtureInput!
}

input FixtureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subTournament: SubTournamentWhereInput
  status: StatusWhereInput
  dateTime: DateTime
  dateTime_not: DateTime
  dateTime_in: [DateTime!]
  dateTime_not_in: [DateTime!]
  dateTime_lt: DateTime
  dateTime_lte: DateTime
  dateTime_gt: DateTime
  dateTime_gte: DateTime
  homeTeam: TeamWhereInput
  awayTeam: TeamWhereInput
  round: RoundWhereInput
  homeTeamParentFixture: FixtureWhereInput
  awayTeamParentFixture: FixtureWhereInput
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FixtureWhereInput!]
  OR: [FixtureWhereInput!]
  NOT: [FixtureWhereInput!]
}

input FixtureWhereUniqueInput {
  id: ID
}

enum FootballActivityType {
  GOAL
  OWN_GOAL
  RED_CARD
  YELLOW_CARD
  DOUBLE_YELLOW_CARD
}

type FootballScore {
  id: ID!
  fixture: Fixture!
  homeTeamFTScore: Int
  awayTeamFTScore: Int
  homeTeamAetScore: Int
  awayTeamAetScore: Int
  homeTeamPenaltyScore: Int
  awayTeamPenaltyScore: Int
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FootballScoreActivity {
  id: ID!
  fixture: Fixture!
  teamPlayer: TeamPlayer!
  activityType: FootballActivityType!
  assistedBy: TeamPlayer
  activityTime: String
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FootballScoreActivityConnection {
  pageInfo: PageInfo!
  edges: [FootballScoreActivityEdge]!
  aggregate: AggregateFootballScoreActivity!
}

input FootballScoreActivityCreateInput {
  fixture: FixtureCreateOneInput!
  teamPlayer: TeamPlayerCreateOneInput!
  activityType: FootballActivityType!
  assistedBy: TeamPlayerCreateOneInput
  activityTime: String
  updatedBy: UserAccountCreateOneInput!
}

type FootballScoreActivityEdge {
  node: FootballScoreActivity!
  cursor: String!
}

enum FootballScoreActivityOrderByInput {
  id_ASC
  id_DESC
  activityType_ASC
  activityType_DESC
  activityTime_ASC
  activityTime_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FootballScoreActivityPreviousValues {
  id: ID!
  activityType: FootballActivityType!
  activityTime: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FootballScoreActivitySubscriptionPayload {
  mutation: MutationType!
  node: FootballScoreActivity
  updatedFields: [String!]
  previousValues: FootballScoreActivityPreviousValues
}

input FootballScoreActivitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FootballScoreActivityWhereInput
  AND: [FootballScoreActivitySubscriptionWhereInput!]
  OR: [FootballScoreActivitySubscriptionWhereInput!]
  NOT: [FootballScoreActivitySubscriptionWhereInput!]
}

input FootballScoreActivityUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  teamPlayer: TeamPlayerUpdateOneRequiredInput
  activityType: FootballActivityType
  assistedBy: TeamPlayerUpdateOneInput
  activityTime: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input FootballScoreActivityUpdateManyMutationInput {
  activityType: FootballActivityType
  activityTime: String
}

input FootballScoreActivityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  teamPlayer: TeamPlayerWhereInput
  activityType: FootballActivityType
  activityType_not: FootballActivityType
  activityType_in: [FootballActivityType!]
  activityType_not_in: [FootballActivityType!]
  assistedBy: TeamPlayerWhereInput
  activityTime: String
  activityTime_not: String
  activityTime_in: [String!]
  activityTime_not_in: [String!]
  activityTime_lt: String
  activityTime_lte: String
  activityTime_gt: String
  activityTime_gte: String
  activityTime_contains: String
  activityTime_not_contains: String
  activityTime_starts_with: String
  activityTime_not_starts_with: String
  activityTime_ends_with: String
  activityTime_not_ends_with: String
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FootballScoreActivityWhereInput!]
  OR: [FootballScoreActivityWhereInput!]
  NOT: [FootballScoreActivityWhereInput!]
}

input FootballScoreActivityWhereUniqueInput {
  id: ID
}

type FootballScoreConnection {
  pageInfo: PageInfo!
  edges: [FootballScoreEdge]!
  aggregate: AggregateFootballScore!
}

input FootballScoreCreateInput {
  fixture: FixtureCreateOneInput!
  homeTeamFTScore: Int
  awayTeamFTScore: Int
  homeTeamAetScore: Int
  awayTeamAetScore: Int
  homeTeamPenaltyScore: Int
  awayTeamPenaltyScore: Int
  updatedBy: UserAccountCreateOneInput!
}

type FootballScoreEdge {
  node: FootballScore!
  cursor: String!
}

enum FootballScoreOrderByInput {
  id_ASC
  id_DESC
  homeTeamFTScore_ASC
  homeTeamFTScore_DESC
  awayTeamFTScore_ASC
  awayTeamFTScore_DESC
  homeTeamAetScore_ASC
  homeTeamAetScore_DESC
  awayTeamAetScore_ASC
  awayTeamAetScore_DESC
  homeTeamPenaltyScore_ASC
  homeTeamPenaltyScore_DESC
  awayTeamPenaltyScore_ASC
  awayTeamPenaltyScore_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FootballScorePreviousValues {
  id: ID!
  homeTeamFTScore: Int
  awayTeamFTScore: Int
  homeTeamAetScore: Int
  awayTeamAetScore: Int
  homeTeamPenaltyScore: Int
  awayTeamPenaltyScore: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FootballScoreSubscriptionPayload {
  mutation: MutationType!
  node: FootballScore
  updatedFields: [String!]
  previousValues: FootballScorePreviousValues
}

input FootballScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FootballScoreWhereInput
  AND: [FootballScoreSubscriptionWhereInput!]
  OR: [FootballScoreSubscriptionWhereInput!]
  NOT: [FootballScoreSubscriptionWhereInput!]
}

input FootballScoreUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  homeTeamFTScore: Int
  awayTeamFTScore: Int
  homeTeamAetScore: Int
  awayTeamAetScore: Int
  homeTeamPenaltyScore: Int
  awayTeamPenaltyScore: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input FootballScoreUpdateManyMutationInput {
  homeTeamFTScore: Int
  awayTeamFTScore: Int
  homeTeamAetScore: Int
  awayTeamAetScore: Int
  homeTeamPenaltyScore: Int
  awayTeamPenaltyScore: Int
}

input FootballScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  homeTeamFTScore: Int
  homeTeamFTScore_not: Int
  homeTeamFTScore_in: [Int!]
  homeTeamFTScore_not_in: [Int!]
  homeTeamFTScore_lt: Int
  homeTeamFTScore_lte: Int
  homeTeamFTScore_gt: Int
  homeTeamFTScore_gte: Int
  awayTeamFTScore: Int
  awayTeamFTScore_not: Int
  awayTeamFTScore_in: [Int!]
  awayTeamFTScore_not_in: [Int!]
  awayTeamFTScore_lt: Int
  awayTeamFTScore_lte: Int
  awayTeamFTScore_gt: Int
  awayTeamFTScore_gte: Int
  homeTeamAetScore: Int
  homeTeamAetScore_not: Int
  homeTeamAetScore_in: [Int!]
  homeTeamAetScore_not_in: [Int!]
  homeTeamAetScore_lt: Int
  homeTeamAetScore_lte: Int
  homeTeamAetScore_gt: Int
  homeTeamAetScore_gte: Int
  awayTeamAetScore: Int
  awayTeamAetScore_not: Int
  awayTeamAetScore_in: [Int!]
  awayTeamAetScore_not_in: [Int!]
  awayTeamAetScore_lt: Int
  awayTeamAetScore_lte: Int
  awayTeamAetScore_gt: Int
  awayTeamAetScore_gte: Int
  homeTeamPenaltyScore: Int
  homeTeamPenaltyScore_not: Int
  homeTeamPenaltyScore_in: [Int!]
  homeTeamPenaltyScore_not_in: [Int!]
  homeTeamPenaltyScore_lt: Int
  homeTeamPenaltyScore_lte: Int
  homeTeamPenaltyScore_gt: Int
  homeTeamPenaltyScore_gte: Int
  awayTeamPenaltyScore: Int
  awayTeamPenaltyScore_not: Int
  awayTeamPenaltyScore_in: [Int!]
  awayTeamPenaltyScore_not_in: [Int!]
  awayTeamPenaltyScore_lt: Int
  awayTeamPenaltyScore_lte: Int
  awayTeamPenaltyScore_gt: Int
  awayTeamPenaltyScore_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FootballScoreWhereInput!]
  OR: [FootballScoreWhereInput!]
  NOT: [FootballScoreWhereInput!]
}

input FootballScoreWhereUniqueInput {
  id: ID
}

type Game {
  id: ID!
  name: String!
  shortName: String!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]!
  aggregate: AggregateGame!
}

input GameCreateInput {
  name: String!
  shortName: String!
  updatedBy: UserAccountCreateOneInput!
}

input GameCreateOneInput {
  create: GameCreateInput
  connect: GameWhereUniqueInput
}

type GameEdge {
  node: Game!
  cursor: String!
}

enum GameOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  shortName_ASC
  shortName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GamePreviousValues {
  id: ID!
  name: String!
  shortName: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GameSubscriptionPayload {
  mutation: MutationType!
  node: Game
  updatedFields: [String!]
  previousValues: GamePreviousValues
}

input GameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameWhereInput
  AND: [GameSubscriptionWhereInput!]
  OR: [GameSubscriptionWhereInput!]
  NOT: [GameSubscriptionWhereInput!]
}

input GameUpdateDataInput {
  name: String
  shortName: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input GameUpdateInput {
  name: String
  shortName: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input GameUpdateManyMutationInput {
  name: String
  shortName: String
}

input GameUpdateOneRequiredInput {
  create: GameCreateInput
  update: GameUpdateDataInput
  upsert: GameUpsertNestedInput
  connect: GameWhereUniqueInput
}

input GameUpsertNestedInput {
  update: GameUpdateDataInput!
  create: GameCreateInput!
}

input GameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  shortName: String
  shortName_not: String
  shortName_in: [String!]
  shortName_not_in: [String!]
  shortName_lt: String
  shortName_lte: String
  shortName_gt: String
  shortName_gte: String
  shortName_contains: String
  shortName_not_contains: String
  shortName_starts_with: String
  shortName_not_starts_with: String
  shortName_ends_with: String
  shortName_not_ends_with: String
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GameWhereInput!]
  OR: [GameWhereInput!]
  NOT: [GameWhereInput!]
}

input GameWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createCarromBoardScore(data: CarromBoardScoreCreateInput!): CarromBoardScore!
  updateCarromBoardScore(data: CarromBoardScoreUpdateInput!, where: CarromBoardScoreWhereUniqueInput!): CarromBoardScore
  updateManyCarromBoardScores(data: CarromBoardScoreUpdateManyMutationInput!, where: CarromBoardScoreWhereInput): BatchPayload!
  upsertCarromBoardScore(where: CarromBoardScoreWhereUniqueInput!, create: CarromBoardScoreCreateInput!, update: CarromBoardScoreUpdateInput!): CarromBoardScore!
  deleteCarromBoardScore(where: CarromBoardScoreWhereUniqueInput!): CarromBoardScore
  deleteManyCarromBoardScores(where: CarromBoardScoreWhereInput): BatchPayload!
  createCarromBoardScoreActivity(data: CarromBoardScoreActivityCreateInput!): CarromBoardScoreActivity!
  updateCarromBoardScoreActivity(data: CarromBoardScoreActivityUpdateInput!, where: CarromBoardScoreActivityWhereUniqueInput!): CarromBoardScoreActivity
  updateManyCarromBoardScoreActivities(data: CarromBoardScoreActivityUpdateManyMutationInput!, where: CarromBoardScoreActivityWhereInput): BatchPayload!
  upsertCarromBoardScoreActivity(where: CarromBoardScoreActivityWhereUniqueInput!, create: CarromBoardScoreActivityCreateInput!, update: CarromBoardScoreActivityUpdateInput!): CarromBoardScoreActivity!
  deleteCarromBoardScoreActivity(where: CarromBoardScoreActivityWhereUniqueInput!): CarromBoardScoreActivity
  deleteManyCarromBoardScoreActivities(where: CarromBoardScoreActivityWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createChessScore(data: ChessScoreCreateInput!): ChessScore!
  updateChessScore(data: ChessScoreUpdateInput!, where: ChessScoreWhereUniqueInput!): ChessScore
  updateManyChessScores(data: ChessScoreUpdateManyMutationInput!, where: ChessScoreWhereInput): BatchPayload!
  upsertChessScore(where: ChessScoreWhereUniqueInput!, create: ChessScoreCreateInput!, update: ChessScoreUpdateInput!): ChessScore!
  deleteChessScore(where: ChessScoreWhereUniqueInput!): ChessScore
  deleteManyChessScores(where: ChessScoreWhereInput): BatchPayload!
  createCounterStrikeFScore(data: CounterStrikeFScoreCreateInput!): CounterStrikeFScore!
  updateCounterStrikeFScore(data: CounterStrikeFScoreUpdateInput!, where: CounterStrikeFScoreWhereUniqueInput!): CounterStrikeFScore
  updateManyCounterStrikeFScores(data: CounterStrikeFScoreUpdateManyMutationInput!, where: CounterStrikeFScoreWhereInput): BatchPayload!
  upsertCounterStrikeFScore(where: CounterStrikeFScoreWhereUniqueInput!, create: CounterStrikeFScoreCreateInput!, update: CounterStrikeFScoreUpdateInput!): CounterStrikeFScore!
  deleteCounterStrikeFScore(where: CounterStrikeFScoreWhereUniqueInput!): CounterStrikeFScore
  deleteManyCounterStrikeFScores(where: CounterStrikeFScoreWhereInput): BatchPayload!
  createCounterStrikeScoreSet(data: CounterStrikeScoreSetCreateInput!): CounterStrikeScoreSet!
  updateCounterStrikeScoreSet(data: CounterStrikeScoreSetUpdateInput!, where: CounterStrikeScoreSetWhereUniqueInput!): CounterStrikeScoreSet
  updateManyCounterStrikeScoreSets(data: CounterStrikeScoreSetUpdateManyMutationInput!, where: CounterStrikeScoreSetWhereInput): BatchPayload!
  upsertCounterStrikeScoreSet(where: CounterStrikeScoreSetWhereUniqueInput!, create: CounterStrikeScoreSetCreateInput!, update: CounterStrikeScoreSetUpdateInput!): CounterStrikeScoreSet!
  deleteCounterStrikeScoreSet(where: CounterStrikeScoreSetWhereUniqueInput!): CounterStrikeScoreSet
  deleteManyCounterStrikeScoreSets(where: CounterStrikeScoreSetWhereInput): BatchPayload!
  createCounterStrikeScoreSetActivity(data: CounterStrikeScoreSetActivityCreateInput!): CounterStrikeScoreSetActivity!
  updateCounterStrikeScoreSetActivity(data: CounterStrikeScoreSetActivityUpdateInput!, where: CounterStrikeScoreSetActivityWhereUniqueInput!): CounterStrikeScoreSetActivity
  updateManyCounterStrikeScoreSetActivities(data: CounterStrikeScoreSetActivityUpdateManyMutationInput!, where: CounterStrikeScoreSetActivityWhereInput): BatchPayload!
  upsertCounterStrikeScoreSetActivity(where: CounterStrikeScoreSetActivityWhereUniqueInput!, create: CounterStrikeScoreSetActivityCreateInput!, update: CounterStrikeScoreSetActivityUpdateInput!): CounterStrikeScoreSetActivity!
  deleteCounterStrikeScoreSetActivity(where: CounterStrikeScoreSetActivityWhereUniqueInput!): CounterStrikeScoreSetActivity
  deleteManyCounterStrikeScoreSetActivities(where: CounterStrikeScoreSetActivityWhereInput): BatchPayload!
  createDotaScore(data: DotaScoreCreateInput!): DotaScore!
  updateDotaScore(data: DotaScoreUpdateInput!, where: DotaScoreWhereUniqueInput!): DotaScore
  updateManyDotaScores(data: DotaScoreUpdateManyMutationInput!, where: DotaScoreWhereInput): BatchPayload!
  upsertDotaScore(where: DotaScoreWhereUniqueInput!, create: DotaScoreCreateInput!, update: DotaScoreUpdateInput!): DotaScore!
  deleteDotaScore(where: DotaScoreWhereUniqueInput!): DotaScore
  deleteManyDotaScores(where: DotaScoreWhereInput): BatchPayload!
  createDotaScoreActivity(data: DotaScoreActivityCreateInput!): DotaScoreActivity!
  updateDotaScoreActivity(data: DotaScoreActivityUpdateInput!, where: DotaScoreActivityWhereUniqueInput!): DotaScoreActivity
  updateManyDotaScoreActivities(data: DotaScoreActivityUpdateManyMutationInput!, where: DotaScoreActivityWhereInput): BatchPayload!
  upsertDotaScoreActivity(where: DotaScoreActivityWhereUniqueInput!, create: DotaScoreActivityCreateInput!, update: DotaScoreActivityUpdateInput!): DotaScoreActivity!
  deleteDotaScoreActivity(where: DotaScoreActivityWhereUniqueInput!): DotaScoreActivity
  deleteManyDotaScoreActivities(where: DotaScoreActivityWhereInput): BatchPayload!
  createEmployee(data: EmployeeCreateInput!): Employee!
  updateEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateManyEmployees(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): BatchPayload!
  upsertEmployee(where: EmployeeWhereUniqueInput!, create: EmployeeCreateInput!, update: EmployeeUpdateInput!): Employee!
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  createFixture(data: FixtureCreateInput!): Fixture!
  updateFixture(data: FixtureUpdateInput!, where: FixtureWhereUniqueInput!): Fixture
  updateManyFixtures(data: FixtureUpdateManyMutationInput!, where: FixtureWhereInput): BatchPayload!
  upsertFixture(where: FixtureWhereUniqueInput!, create: FixtureCreateInput!, update: FixtureUpdateInput!): Fixture!
  deleteFixture(where: FixtureWhereUniqueInput!): Fixture
  deleteManyFixtures(where: FixtureWhereInput): BatchPayload!
  createFootballScore(data: FootballScoreCreateInput!): FootballScore!
  updateFootballScore(data: FootballScoreUpdateInput!, where: FootballScoreWhereUniqueInput!): FootballScore
  updateManyFootballScores(data: FootballScoreUpdateManyMutationInput!, where: FootballScoreWhereInput): BatchPayload!
  upsertFootballScore(where: FootballScoreWhereUniqueInput!, create: FootballScoreCreateInput!, update: FootballScoreUpdateInput!): FootballScore!
  deleteFootballScore(where: FootballScoreWhereUniqueInput!): FootballScore
  deleteManyFootballScores(where: FootballScoreWhereInput): BatchPayload!
  createFootballScoreActivity(data: FootballScoreActivityCreateInput!): FootballScoreActivity!
  updateFootballScoreActivity(data: FootballScoreActivityUpdateInput!, where: FootballScoreActivityWhereUniqueInput!): FootballScoreActivity
  updateManyFootballScoreActivities(data: FootballScoreActivityUpdateManyMutationInput!, where: FootballScoreActivityWhereInput): BatchPayload!
  upsertFootballScoreActivity(where: FootballScoreActivityWhereUniqueInput!, create: FootballScoreActivityCreateInput!, update: FootballScoreActivityUpdateInput!): FootballScoreActivity!
  deleteFootballScoreActivity(where: FootballScoreActivityWhereUniqueInput!): FootballScoreActivity
  deleteManyFootballScoreActivities(where: FootballScoreActivityWhereInput): BatchPayload!
  createGame(data: GameCreateInput!): Game!
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateManyGames(data: GameUpdateManyMutationInput!, where: GameWhereInput): BatchPayload!
  upsertGame(where: GameWhereUniqueInput!, create: GameCreateInput!, update: GameUpdateInput!): Game!
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteManyGames(where: GameWhereInput): BatchPayload!
  createRound(data: RoundCreateInput!): Round!
  updateRound(data: RoundUpdateInput!, where: RoundWhereUniqueInput!): Round
  updateManyRounds(data: RoundUpdateManyMutationInput!, where: RoundWhereInput): BatchPayload!
  upsertRound(where: RoundWhereUniqueInput!, create: RoundCreateInput!, update: RoundUpdateInput!): Round!
  deleteRound(where: RoundWhereUniqueInput!): Round
  deleteManyRounds(where: RoundWhereInput): BatchPayload!
  createStatus(data: StatusCreateInput!): Status!
  updateStatus(data: StatusUpdateInput!, where: StatusWhereUniqueInput!): Status
  updateManyStatuses(data: StatusUpdateManyMutationInput!, where: StatusWhereInput): BatchPayload!
  upsertStatus(where: StatusWhereUniqueInput!, create: StatusCreateInput!, update: StatusUpdateInput!): Status!
  deleteStatus(where: StatusWhereUniqueInput!): Status
  deleteManyStatuses(where: StatusWhereInput): BatchPayload!
  createSubTournament(data: SubTournamentCreateInput!): SubTournament!
  updateSubTournament(data: SubTournamentUpdateInput!, where: SubTournamentWhereUniqueInput!): SubTournament
  upsertSubTournament(where: SubTournamentWhereUniqueInput!, create: SubTournamentCreateInput!, update: SubTournamentUpdateInput!): SubTournament!
  deleteSubTournament(where: SubTournamentWhereUniqueInput!): SubTournament
  deleteManySubTournaments(where: SubTournamentWhereInput): BatchPayload!
  createSubTournamentPlayer(data: SubTournamentPlayerCreateInput!): SubTournamentPlayer!
  updateSubTournamentPlayer(data: SubTournamentPlayerUpdateInput!, where: SubTournamentPlayerWhereUniqueInput!): SubTournamentPlayer
  updateManySubTournamentPlayers(data: SubTournamentPlayerUpdateManyMutationInput!, where: SubTournamentPlayerWhereInput): BatchPayload!
  upsertSubTournamentPlayer(where: SubTournamentPlayerWhereUniqueInput!, create: SubTournamentPlayerCreateInput!, update: SubTournamentPlayerUpdateInput!): SubTournamentPlayer!
  deleteSubTournamentPlayer(where: SubTournamentPlayerWhereUniqueInput!): SubTournamentPlayer
  deleteManySubTournamentPlayers(where: SubTournamentPlayerWhereInput): BatchPayload!
  createTableTennisScore(data: TableTennisScoreCreateInput!): TableTennisScore!
  updateTableTennisScore(data: TableTennisScoreUpdateInput!, where: TableTennisScoreWhereUniqueInput!): TableTennisScore
  updateManyTableTennisScores(data: TableTennisScoreUpdateManyMutationInput!, where: TableTennisScoreWhereInput): BatchPayload!
  upsertTableTennisScore(where: TableTennisScoreWhereUniqueInput!, create: TableTennisScoreCreateInput!, update: TableTennisScoreUpdateInput!): TableTennisScore!
  deleteTableTennisScore(where: TableTennisScoreWhereUniqueInput!): TableTennisScore
  deleteManyTableTennisScores(where: TableTennisScoreWhereInput): BatchPayload!
  createTableTennisScoreActivity(data: TableTennisScoreActivityCreateInput!): TableTennisScoreActivity!
  updateTableTennisScoreActivity(data: TableTennisScoreActivityUpdateInput!, where: TableTennisScoreActivityWhereUniqueInput!): TableTennisScoreActivity
  updateManyTableTennisScoreActivities(data: TableTennisScoreActivityUpdateManyMutationInput!, where: TableTennisScoreActivityWhereInput): BatchPayload!
  upsertTableTennisScoreActivity(where: TableTennisScoreActivityWhereUniqueInput!, create: TableTennisScoreActivityCreateInput!, update: TableTennisScoreActivityUpdateInput!): TableTennisScoreActivity!
  deleteTableTennisScoreActivity(where: TableTennisScoreActivityWhereUniqueInput!): TableTennisScoreActivity
  deleteManyTableTennisScoreActivities(where: TableTennisScoreActivityWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createTeamPlayer(data: TeamPlayerCreateInput!): TeamPlayer!
  updateTeamPlayer(data: TeamPlayerUpdateInput!, where: TeamPlayerWhereUniqueInput!): TeamPlayer
  updateManyTeamPlayers(data: TeamPlayerUpdateManyMutationInput!, where: TeamPlayerWhereInput): BatchPayload!
  upsertTeamPlayer(where: TeamPlayerWhereUniqueInput!, create: TeamPlayerCreateInput!, update: TeamPlayerUpdateInput!): TeamPlayer!
  deleteTeamPlayer(where: TeamPlayerWhereUniqueInput!): TeamPlayer
  deleteManyTeamPlayers(where: TeamPlayerWhereInput): BatchPayload!
  createTournament(data: TournamentCreateInput!): Tournament!
  updateTournament(data: TournamentUpdateInput!, where: TournamentWhereUniqueInput!): Tournament
  updateManyTournaments(data: TournamentUpdateManyMutationInput!, where: TournamentWhereInput): BatchPayload!
  upsertTournament(where: TournamentWhereUniqueInput!, create: TournamentCreateInput!, update: TournamentUpdateInput!): Tournament!
  deleteTournament(where: TournamentWhereUniqueInput!): Tournament
  deleteManyTournaments(where: TournamentWhereInput): BatchPayload!
  createUserAccount(data: UserAccountCreateInput!): UserAccount!
  updateUserAccount(data: UserAccountUpdateInput!, where: UserAccountWhereUniqueInput!): UserAccount
  updateManyUserAccounts(data: UserAccountUpdateManyMutationInput!, where: UserAccountWhereInput): BatchPayload!
  upsertUserAccount(where: UserAccountWhereUniqueInput!, create: UserAccountCreateInput!, update: UserAccountUpdateInput!): UserAccount!
  deleteUserAccount(where: UserAccountWhereUniqueInput!): UserAccount
  deleteManyUserAccounts(where: UserAccountWhereInput): BatchPayload!
  createUserAccountToken(data: UserAccountTokenCreateInput!): UserAccountToken!
  updateUserAccountToken(data: UserAccountTokenUpdateInput!, where: UserAccountTokenWhereUniqueInput!): UserAccountToken
  updateManyUserAccountTokens(data: UserAccountTokenUpdateManyMutationInput!, where: UserAccountTokenWhereInput): BatchPayload!
  upsertUserAccountToken(where: UserAccountTokenWhereUniqueInput!, create: UserAccountTokenCreateInput!, update: UserAccountTokenUpdateInput!): UserAccountToken!
  deleteUserAccountToken(where: UserAccountTokenWhereUniqueInput!): UserAccountToken
  deleteManyUserAccountTokens(where: UserAccountTokenWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  carromBoardScore(where: CarromBoardScoreWhereUniqueInput!): CarromBoardScore
  carromBoardScores(where: CarromBoardScoreWhereInput, orderBy: CarromBoardScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CarromBoardScore]!
  carromBoardScoresConnection(where: CarromBoardScoreWhereInput, orderBy: CarromBoardScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CarromBoardScoreConnection!
  carromBoardScoreActivity(where: CarromBoardScoreActivityWhereUniqueInput!): CarromBoardScoreActivity
  carromBoardScoreActivities(where: CarromBoardScoreActivityWhereInput, orderBy: CarromBoardScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CarromBoardScoreActivity]!
  carromBoardScoreActivitiesConnection(where: CarromBoardScoreActivityWhereInput, orderBy: CarromBoardScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CarromBoardScoreActivityConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  chessScore(where: ChessScoreWhereUniqueInput!): ChessScore
  chessScores(where: ChessScoreWhereInput, orderBy: ChessScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChessScore]!
  chessScoresConnection(where: ChessScoreWhereInput, orderBy: ChessScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChessScoreConnection!
  counterStrikeFScore(where: CounterStrikeFScoreWhereUniqueInput!): CounterStrikeFScore
  counterStrikeFScores(where: CounterStrikeFScoreWhereInput, orderBy: CounterStrikeFScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CounterStrikeFScore]!
  counterStrikeFScoresConnection(where: CounterStrikeFScoreWhereInput, orderBy: CounterStrikeFScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CounterStrikeFScoreConnection!
  counterStrikeScoreSet(where: CounterStrikeScoreSetWhereUniqueInput!): CounterStrikeScoreSet
  counterStrikeScoreSets(where: CounterStrikeScoreSetWhereInput, orderBy: CounterStrikeScoreSetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CounterStrikeScoreSet]!
  counterStrikeScoreSetsConnection(where: CounterStrikeScoreSetWhereInput, orderBy: CounterStrikeScoreSetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CounterStrikeScoreSetConnection!
  counterStrikeScoreSetActivity(where: CounterStrikeScoreSetActivityWhereUniqueInput!): CounterStrikeScoreSetActivity
  counterStrikeScoreSetActivities(where: CounterStrikeScoreSetActivityWhereInput, orderBy: CounterStrikeScoreSetActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CounterStrikeScoreSetActivity]!
  counterStrikeScoreSetActivitiesConnection(where: CounterStrikeScoreSetActivityWhereInput, orderBy: CounterStrikeScoreSetActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CounterStrikeScoreSetActivityConnection!
  dotaScore(where: DotaScoreWhereUniqueInput!): DotaScore
  dotaScores(where: DotaScoreWhereInput, orderBy: DotaScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DotaScore]!
  dotaScoresConnection(where: DotaScoreWhereInput, orderBy: DotaScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DotaScoreConnection!
  dotaScoreActivity(where: DotaScoreActivityWhereUniqueInput!): DotaScoreActivity
  dotaScoreActivities(where: DotaScoreActivityWhereInput, orderBy: DotaScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DotaScoreActivity]!
  dotaScoreActivitiesConnection(where: DotaScoreActivityWhereInput, orderBy: DotaScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DotaScoreActivityConnection!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employee]!
  employeesConnection(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeeConnection!
  fixture(where: FixtureWhereUniqueInput!): Fixture
  fixtures(where: FixtureWhereInput, orderBy: FixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fixture]!
  fixturesConnection(where: FixtureWhereInput, orderBy: FixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FixtureConnection!
  footballScore(where: FootballScoreWhereUniqueInput!): FootballScore
  footballScores(where: FootballScoreWhereInput, orderBy: FootballScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FootballScore]!
  footballScoresConnection(where: FootballScoreWhereInput, orderBy: FootballScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FootballScoreConnection!
  footballScoreActivity(where: FootballScoreActivityWhereUniqueInput!): FootballScoreActivity
  footballScoreActivities(where: FootballScoreActivityWhereInput, orderBy: FootballScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FootballScoreActivity]!
  footballScoreActivitiesConnection(where: FootballScoreActivityWhereInput, orderBy: FootballScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FootballScoreActivityConnection!
  game(where: GameWhereUniqueInput!): Game
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game]!
  gamesConnection(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameConnection!
  round(where: RoundWhereUniqueInput!): Round
  rounds(where: RoundWhereInput, orderBy: RoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Round]!
  roundsConnection(where: RoundWhereInput, orderBy: RoundOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoundConnection!
  status(where: StatusWhereUniqueInput!): Status
  statuses(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Status]!
  statusesConnection(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StatusConnection!
  subTournament(where: SubTournamentWhereUniqueInput!): SubTournament
  subTournaments(where: SubTournamentWhereInput, orderBy: SubTournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTournament]!
  subTournamentsConnection(where: SubTournamentWhereInput, orderBy: SubTournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubTournamentConnection!
  subTournamentPlayer(where: SubTournamentPlayerWhereUniqueInput!): SubTournamentPlayer
  subTournamentPlayers(where: SubTournamentPlayerWhereInput, orderBy: SubTournamentPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTournamentPlayer]!
  subTournamentPlayersConnection(where: SubTournamentPlayerWhereInput, orderBy: SubTournamentPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubTournamentPlayerConnection!
  tableTennisScore(where: TableTennisScoreWhereUniqueInput!): TableTennisScore
  tableTennisScores(where: TableTennisScoreWhereInput, orderBy: TableTennisScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TableTennisScore]!
  tableTennisScoresConnection(where: TableTennisScoreWhereInput, orderBy: TableTennisScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TableTennisScoreConnection!
  tableTennisScoreActivity(where: TableTennisScoreActivityWhereUniqueInput!): TableTennisScoreActivity
  tableTennisScoreActivities(where: TableTennisScoreActivityWhereInput, orderBy: TableTennisScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TableTennisScoreActivity]!
  tableTennisScoreActivitiesConnection(where: TableTennisScoreActivityWhereInput, orderBy: TableTennisScoreActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TableTennisScoreActivityConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  teamPlayer(where: TeamPlayerWhereUniqueInput!): TeamPlayer
  teamPlayers(where: TeamPlayerWhereInput, orderBy: TeamPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamPlayer]!
  teamPlayersConnection(where: TeamPlayerWhereInput, orderBy: TeamPlayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamPlayerConnection!
  tournament(where: TournamentWhereUniqueInput!): Tournament
  tournaments(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tournament]!
  tournamentsConnection(where: TournamentWhereInput, orderBy: TournamentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TournamentConnection!
  userAccount(where: UserAccountWhereUniqueInput!): UserAccount
  userAccounts(where: UserAccountWhereInput, orderBy: UserAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAccount]!
  userAccountsConnection(where: UserAccountWhereInput, orderBy: UserAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAccountConnection!
  userAccountToken(where: UserAccountTokenWhereUniqueInput!): UserAccountToken
  userAccountTokens(where: UserAccountTokenWhereInput, orderBy: UserAccountTokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAccountToken]!
  userAccountTokensConnection(where: UserAccountTokenWhereInput, orderBy: UserAccountTokenOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAccountTokenConnection!
  node(id: ID!): Node
}

type Round {
  id: ID!
  name: String!
  shortName: String!
  sortOrder: Int!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RoundConnection {
  pageInfo: PageInfo!
  edges: [RoundEdge]!
  aggregate: AggregateRound!
}

input RoundCreateInput {
  name: String!
  shortName: String!
  sortOrder: Int!
  updatedBy: UserAccountCreateOneInput!
}

input RoundCreateOneInput {
  create: RoundCreateInput
  connect: RoundWhereUniqueInput
}

type RoundEdge {
  node: Round!
  cursor: String!
}

enum RoundOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  shortName_ASC
  shortName_DESC
  sortOrder_ASC
  sortOrder_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RoundPreviousValues {
  id: ID!
  name: String!
  shortName: String!
  sortOrder: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RoundSubscriptionPayload {
  mutation: MutationType!
  node: Round
  updatedFields: [String!]
  previousValues: RoundPreviousValues
}

input RoundSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoundWhereInput
  AND: [RoundSubscriptionWhereInput!]
  OR: [RoundSubscriptionWhereInput!]
  NOT: [RoundSubscriptionWhereInput!]
}

input RoundUpdateDataInput {
  name: String
  shortName: String
  sortOrder: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input RoundUpdateInput {
  name: String
  shortName: String
  sortOrder: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input RoundUpdateManyMutationInput {
  name: String
  shortName: String
  sortOrder: Int
}

input RoundUpdateOneRequiredInput {
  create: RoundCreateInput
  update: RoundUpdateDataInput
  upsert: RoundUpsertNestedInput
  connect: RoundWhereUniqueInput
}

input RoundUpsertNestedInput {
  update: RoundUpdateDataInput!
  create: RoundCreateInput!
}

input RoundWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  shortName: String
  shortName_not: String
  shortName_in: [String!]
  shortName_not_in: [String!]
  shortName_lt: String
  shortName_lte: String
  shortName_gt: String
  shortName_gte: String
  shortName_contains: String
  shortName_not_contains: String
  shortName_starts_with: String
  shortName_not_starts_with: String
  shortName_ends_with: String
  shortName_not_ends_with: String
  sortOrder: Int
  sortOrder_not: Int
  sortOrder_in: [Int!]
  sortOrder_not_in: [Int!]
  sortOrder_lt: Int
  sortOrder_lte: Int
  sortOrder_gt: Int
  sortOrder_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RoundWhereInput!]
  OR: [RoundWhereInput!]
  NOT: [RoundWhereInput!]
}

input RoundWhereUniqueInput {
  id: ID
}

type Status {
  id: ID!
  name: String!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatusConnection {
  pageInfo: PageInfo!
  edges: [StatusEdge]!
  aggregate: AggregateStatus!
}

input StatusCreateInput {
  name: String!
  updatedBy: UserAccountCreateOneInput!
}

input StatusCreateOneInput {
  create: StatusCreateInput
  connect: StatusWhereUniqueInput
}

type StatusEdge {
  node: Status!
  cursor: String!
}

enum StatusOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StatusPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatusSubscriptionPayload {
  mutation: MutationType!
  node: Status
  updatedFields: [String!]
  previousValues: StatusPreviousValues
}

input StatusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StatusWhereInput
  AND: [StatusSubscriptionWhereInput!]
  OR: [StatusSubscriptionWhereInput!]
  NOT: [StatusSubscriptionWhereInput!]
}

input StatusUpdateDataInput {
  name: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input StatusUpdateInput {
  name: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input StatusUpdateManyMutationInput {
  name: String
}

input StatusUpdateOneRequiredInput {
  create: StatusCreateInput
  update: StatusUpdateDataInput
  upsert: StatusUpsertNestedInput
  connect: StatusWhereUniqueInput
}

input StatusUpsertNestedInput {
  update: StatusUpdateDataInput!
  create: StatusCreateInput!
}

input StatusWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StatusWhereInput!]
  OR: [StatusWhereInput!]
  NOT: [StatusWhereInput!]
}

input StatusWhereUniqueInput {
  id: ID
}

type Subscription {
  carromBoardScore(where: CarromBoardScoreSubscriptionWhereInput): CarromBoardScoreSubscriptionPayload
  carromBoardScoreActivity(where: CarromBoardScoreActivitySubscriptionWhereInput): CarromBoardScoreActivitySubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  chessScore(where: ChessScoreSubscriptionWhereInput): ChessScoreSubscriptionPayload
  counterStrikeFScore(where: CounterStrikeFScoreSubscriptionWhereInput): CounterStrikeFScoreSubscriptionPayload
  counterStrikeScoreSet(where: CounterStrikeScoreSetSubscriptionWhereInput): CounterStrikeScoreSetSubscriptionPayload
  counterStrikeScoreSetActivity(where: CounterStrikeScoreSetActivitySubscriptionWhereInput): CounterStrikeScoreSetActivitySubscriptionPayload
  dotaScore(where: DotaScoreSubscriptionWhereInput): DotaScoreSubscriptionPayload
  dotaScoreActivity(where: DotaScoreActivitySubscriptionWhereInput): DotaScoreActivitySubscriptionPayload
  employee(where: EmployeeSubscriptionWhereInput): EmployeeSubscriptionPayload
  fixture(where: FixtureSubscriptionWhereInput): FixtureSubscriptionPayload
  footballScore(where: FootballScoreSubscriptionWhereInput): FootballScoreSubscriptionPayload
  footballScoreActivity(where: FootballScoreActivitySubscriptionWhereInput): FootballScoreActivitySubscriptionPayload
  game(where: GameSubscriptionWhereInput): GameSubscriptionPayload
  round(where: RoundSubscriptionWhereInput): RoundSubscriptionPayload
  status(where: StatusSubscriptionWhereInput): StatusSubscriptionPayload
  subTournament(where: SubTournamentSubscriptionWhereInput): SubTournamentSubscriptionPayload
  subTournamentPlayer(where: SubTournamentPlayerSubscriptionWhereInput): SubTournamentPlayerSubscriptionPayload
  tableTennisScore(where: TableTennisScoreSubscriptionWhereInput): TableTennisScoreSubscriptionPayload
  tableTennisScoreActivity(where: TableTennisScoreActivitySubscriptionWhereInput): TableTennisScoreActivitySubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  teamPlayer(where: TeamPlayerSubscriptionWhereInput): TeamPlayerSubscriptionPayload
  tournament(where: TournamentSubscriptionWhereInput): TournamentSubscriptionPayload
  userAccount(where: UserAccountSubscriptionWhereInput): UserAccountSubscriptionPayload
  userAccountToken(where: UserAccountTokenSubscriptionWhereInput): UserAccountTokenSubscriptionPayload
}

type SubTournament {
  id: ID!
  tournament: Tournament!
  category: Category!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubTournamentConnection {
  pageInfo: PageInfo!
  edges: [SubTournamentEdge]!
  aggregate: AggregateSubTournament!
}

input SubTournamentCreateInput {
  tournament: TournamentCreateOneInput!
  category: CategoryCreateOneInput!
  updatedBy: UserAccountCreateOneInput!
}

input SubTournamentCreateOneInput {
  create: SubTournamentCreateInput
  connect: SubTournamentWhereUniqueInput
}

type SubTournamentEdge {
  node: SubTournament!
  cursor: String!
}

enum SubTournamentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubTournamentPlayer {
  id: ID!
  subTournament: SubTournament!
  player: Employee!
  position: String
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubTournamentPlayerConnection {
  pageInfo: PageInfo!
  edges: [SubTournamentPlayerEdge]!
  aggregate: AggregateSubTournamentPlayer!
}

input SubTournamentPlayerCreateInput {
  subTournament: SubTournamentCreateOneInput!
  player: EmployeeCreateOneInput!
  position: String
  updatedBy: UserAccountCreateOneInput!
}

input SubTournamentPlayerCreateOneInput {
  create: SubTournamentPlayerCreateInput
  connect: SubTournamentPlayerWhereUniqueInput
}

type SubTournamentPlayerEdge {
  node: SubTournamentPlayer!
  cursor: String!
}

enum SubTournamentPlayerOrderByInput {
  id_ASC
  id_DESC
  position_ASC
  position_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubTournamentPlayerPreviousValues {
  id: ID!
  position: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubTournamentPlayerSubscriptionPayload {
  mutation: MutationType!
  node: SubTournamentPlayer
  updatedFields: [String!]
  previousValues: SubTournamentPlayerPreviousValues
}

input SubTournamentPlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubTournamentPlayerWhereInput
  AND: [SubTournamentPlayerSubscriptionWhereInput!]
  OR: [SubTournamentPlayerSubscriptionWhereInput!]
  NOT: [SubTournamentPlayerSubscriptionWhereInput!]
}

input SubTournamentPlayerUpdateDataInput {
  subTournament: SubTournamentUpdateOneRequiredInput
  player: EmployeeUpdateOneRequiredInput
  position: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input SubTournamentPlayerUpdateInput {
  subTournament: SubTournamentUpdateOneRequiredInput
  player: EmployeeUpdateOneRequiredInput
  position: String
  updatedBy: UserAccountUpdateOneRequiredInput
}

input SubTournamentPlayerUpdateManyMutationInput {
  position: String
}

input SubTournamentPlayerUpdateOneRequiredInput {
  create: SubTournamentPlayerCreateInput
  update: SubTournamentPlayerUpdateDataInput
  upsert: SubTournamentPlayerUpsertNestedInput
  connect: SubTournamentPlayerWhereUniqueInput
}

input SubTournamentPlayerUpsertNestedInput {
  update: SubTournamentPlayerUpdateDataInput!
  create: SubTournamentPlayerCreateInput!
}

input SubTournamentPlayerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subTournament: SubTournamentWhereInput
  player: EmployeeWhereInput
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SubTournamentPlayerWhereInput!]
  OR: [SubTournamentPlayerWhereInput!]
  NOT: [SubTournamentPlayerWhereInput!]
}

input SubTournamentPlayerWhereUniqueInput {
  id: ID
}

type SubTournamentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubTournamentSubscriptionPayload {
  mutation: MutationType!
  node: SubTournament
  updatedFields: [String!]
  previousValues: SubTournamentPreviousValues
}

input SubTournamentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubTournamentWhereInput
  AND: [SubTournamentSubscriptionWhereInput!]
  OR: [SubTournamentSubscriptionWhereInput!]
  NOT: [SubTournamentSubscriptionWhereInput!]
}

input SubTournamentUpdateDataInput {
  tournament: TournamentUpdateOneRequiredInput
  category: CategoryUpdateOneRequiredInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input SubTournamentUpdateInput {
  tournament: TournamentUpdateOneRequiredInput
  category: CategoryUpdateOneRequiredInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input SubTournamentUpdateOneRequiredInput {
  create: SubTournamentCreateInput
  update: SubTournamentUpdateDataInput
  upsert: SubTournamentUpsertNestedInput
  connect: SubTournamentWhereUniqueInput
}

input SubTournamentUpsertNestedInput {
  update: SubTournamentUpdateDataInput!
  create: SubTournamentCreateInput!
}

input SubTournamentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tournament: TournamentWhereInput
  category: CategoryWhereInput
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SubTournamentWhereInput!]
  OR: [SubTournamentWhereInput!]
  NOT: [SubTournamentWhereInput!]
}

input SubTournamentWhereUniqueInput {
  id: ID
}

type TableTennisScore {
  id: ID!
  fixture: Fixture!
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TableTennisScoreActivity {
  id: ID!
  fixture: Fixture!
  set: Int!
  homeTeamPoints: Int!
  awayTeamPoints: Int!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TableTennisScoreActivityConnection {
  pageInfo: PageInfo!
  edges: [TableTennisScoreActivityEdge]!
  aggregate: AggregateTableTennisScoreActivity!
}

input TableTennisScoreActivityCreateInput {
  fixture: FixtureCreateOneInput!
  set: Int!
  homeTeamPoints: Int!
  awayTeamPoints: Int!
  updatedBy: UserAccountCreateOneInput!
}

type TableTennisScoreActivityEdge {
  node: TableTennisScoreActivity!
  cursor: String!
}

enum TableTennisScoreActivityOrderByInput {
  id_ASC
  id_DESC
  set_ASC
  set_DESC
  homeTeamPoints_ASC
  homeTeamPoints_DESC
  awayTeamPoints_ASC
  awayTeamPoints_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TableTennisScoreActivityPreviousValues {
  id: ID!
  set: Int!
  homeTeamPoints: Int!
  awayTeamPoints: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TableTennisScoreActivitySubscriptionPayload {
  mutation: MutationType!
  node: TableTennisScoreActivity
  updatedFields: [String!]
  previousValues: TableTennisScoreActivityPreviousValues
}

input TableTennisScoreActivitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TableTennisScoreActivityWhereInput
  AND: [TableTennisScoreActivitySubscriptionWhereInput!]
  OR: [TableTennisScoreActivitySubscriptionWhereInput!]
  NOT: [TableTennisScoreActivitySubscriptionWhereInput!]
}

input TableTennisScoreActivityUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  set: Int
  homeTeamPoints: Int
  awayTeamPoints: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TableTennisScoreActivityUpdateManyMutationInput {
  set: Int
  homeTeamPoints: Int
  awayTeamPoints: Int
}

input TableTennisScoreActivityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  set: Int
  set_not: Int
  set_in: [Int!]
  set_not_in: [Int!]
  set_lt: Int
  set_lte: Int
  set_gt: Int
  set_gte: Int
  homeTeamPoints: Int
  homeTeamPoints_not: Int
  homeTeamPoints_in: [Int!]
  homeTeamPoints_not_in: [Int!]
  homeTeamPoints_lt: Int
  homeTeamPoints_lte: Int
  homeTeamPoints_gt: Int
  homeTeamPoints_gte: Int
  awayTeamPoints: Int
  awayTeamPoints_not: Int
  awayTeamPoints_in: [Int!]
  awayTeamPoints_not_in: [Int!]
  awayTeamPoints_lt: Int
  awayTeamPoints_lte: Int
  awayTeamPoints_gt: Int
  awayTeamPoints_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TableTennisScoreActivityWhereInput!]
  OR: [TableTennisScoreActivityWhereInput!]
  NOT: [TableTennisScoreActivityWhereInput!]
}

input TableTennisScoreActivityWhereUniqueInput {
  id: ID
}

type TableTennisScoreConnection {
  pageInfo: PageInfo!
  edges: [TableTennisScoreEdge]!
  aggregate: AggregateTableTennisScore!
}

input TableTennisScoreCreateInput {
  fixture: FixtureCreateOneInput!
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int!
  updatedBy: UserAccountCreateOneInput!
}

type TableTennisScoreEdge {
  node: TableTennisScore!
  cursor: String!
}

enum TableTennisScoreOrderByInput {
  id_ASC
  id_DESC
  homeTeamScore_ASC
  homeTeamScore_DESC
  awayTeamScore_ASC
  awayTeamScore_DESC
  setsCount_ASC
  setsCount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TableTennisScorePreviousValues {
  id: ID!
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TableTennisScoreSubscriptionPayload {
  mutation: MutationType!
  node: TableTennisScore
  updatedFields: [String!]
  previousValues: TableTennisScorePreviousValues
}

input TableTennisScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TableTennisScoreWhereInput
  AND: [TableTennisScoreSubscriptionWhereInput!]
  OR: [TableTennisScoreSubscriptionWhereInput!]
  NOT: [TableTennisScoreSubscriptionWhereInput!]
}

input TableTennisScoreUpdateInput {
  fixture: FixtureUpdateOneRequiredInput
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TableTennisScoreUpdateManyMutationInput {
  homeTeamScore: Int
  awayTeamScore: Int
  setsCount: Int
}

input TableTennisScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  homeTeamScore: Int
  homeTeamScore_not: Int
  homeTeamScore_in: [Int!]
  homeTeamScore_not_in: [Int!]
  homeTeamScore_lt: Int
  homeTeamScore_lte: Int
  homeTeamScore_gt: Int
  homeTeamScore_gte: Int
  awayTeamScore: Int
  awayTeamScore_not: Int
  awayTeamScore_in: [Int!]
  awayTeamScore_not_in: [Int!]
  awayTeamScore_lt: Int
  awayTeamScore_lte: Int
  awayTeamScore_gt: Int
  awayTeamScore_gte: Int
  setsCount: Int
  setsCount_not: Int
  setsCount_in: [Int!]
  setsCount_not_in: [Int!]
  setsCount_lt: Int
  setsCount_lte: Int
  setsCount_gt: Int
  setsCount_gte: Int
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TableTennisScoreWhereInput!]
  OR: [TableTennisScoreWhereInput!]
  NOT: [TableTennisScoreWhereInput!]
}

input TableTennisScoreWhereUniqueInput {
  id: ID
}

type Team {
  id: ID!
  name: String!
  logoImage: String
  subTournament: SubTournament!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  name: String!
  logoImage: String
  subTournament: SubTournamentCreateOneInput!
  updatedBy: UserAccountCreateOneInput!
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  logoImage_ASC
  logoImage_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeamPlayer {
  id: ID!
  team: Team!
  player: SubTournamentPlayer!
  isCaptain: Boolean!
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamPlayerConnection {
  pageInfo: PageInfo!
  edges: [TeamPlayerEdge]!
  aggregate: AggregateTeamPlayer!
}

input TeamPlayerCreateInput {
  team: TeamCreateOneInput!
  player: SubTournamentPlayerCreateOneInput!
  isCaptain: Boolean
  updatedBy: UserAccountCreateOneInput!
}

input TeamPlayerCreateOneInput {
  create: TeamPlayerCreateInput
  connect: TeamPlayerWhereUniqueInput
}

type TeamPlayerEdge {
  node: TeamPlayer!
  cursor: String!
}

enum TeamPlayerOrderByInput {
  id_ASC
  id_DESC
  isCaptain_ASC
  isCaptain_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeamPlayerPreviousValues {
  id: ID!
  isCaptain: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamPlayerSubscriptionPayload {
  mutation: MutationType!
  node: TeamPlayer
  updatedFields: [String!]
  previousValues: TeamPlayerPreviousValues
}

input TeamPlayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamPlayerWhereInput
  AND: [TeamPlayerSubscriptionWhereInput!]
  OR: [TeamPlayerSubscriptionWhereInput!]
  NOT: [TeamPlayerSubscriptionWhereInput!]
}

input TeamPlayerUpdateDataInput {
  team: TeamUpdateOneRequiredInput
  player: SubTournamentPlayerUpdateOneRequiredInput
  isCaptain: Boolean
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TeamPlayerUpdateInput {
  team: TeamUpdateOneRequiredInput
  player: SubTournamentPlayerUpdateOneRequiredInput
  isCaptain: Boolean
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TeamPlayerUpdateManyMutationInput {
  isCaptain: Boolean
}

input TeamPlayerUpdateOneInput {
  create: TeamPlayerCreateInput
  update: TeamPlayerUpdateDataInput
  upsert: TeamPlayerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamPlayerWhereUniqueInput
}

input TeamPlayerUpdateOneRequiredInput {
  create: TeamPlayerCreateInput
  update: TeamPlayerUpdateDataInput
  upsert: TeamPlayerUpsertNestedInput
  connect: TeamPlayerWhereUniqueInput
}

input TeamPlayerUpsertNestedInput {
  update: TeamPlayerUpdateDataInput!
  create: TeamPlayerCreateInput!
}

input TeamPlayerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  team: TeamWhereInput
  player: SubTournamentPlayerWhereInput
  isCaptain: Boolean
  isCaptain_not: Boolean
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TeamPlayerWhereInput!]
  OR: [TeamPlayerWhereInput!]
  NOT: [TeamPlayerWhereInput!]
}

input TeamPlayerWhereUniqueInput {
  id: ID
}

type TeamPreviousValues {
  id: ID!
  name: String!
  logoImage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateDataInput {
  name: String
  logoImage: String
  subTournament: SubTournamentUpdateOneRequiredInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TeamUpdateInput {
  name: String
  logoImage: String
  subTournament: SubTournamentUpdateOneRequiredInput
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TeamUpdateManyMutationInput {
  name: String
  logoImage: String
}

input TeamUpdateOneInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  connect: TeamWhereUniqueInput
}

input TeamUpsertNestedInput {
  update: TeamUpdateDataInput!
  create: TeamCreateInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  logoImage: String
  logoImage_not: String
  logoImage_in: [String!]
  logoImage_not_in: [String!]
  logoImage_lt: String
  logoImage_lte: String
  logoImage_gt: String
  logoImage_gte: String
  logoImage_contains: String
  logoImage_not_contains: String
  logoImage_starts_with: String
  logoImage_not_starts_with: String
  logoImage_ends_with: String
  logoImage_not_ends_with: String
  subTournament: SubTournamentWhereInput
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
}

type Tournament {
  id: ID!
  game: Game!
  season: String!
  startDate: DateTime!
  finishDate: DateTime
  updatedBy: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TournamentConnection {
  pageInfo: PageInfo!
  edges: [TournamentEdge]!
  aggregate: AggregateTournament!
}

input TournamentCreateInput {
  game: GameCreateOneInput!
  season: String!
  startDate: DateTime!
  finishDate: DateTime
  updatedBy: UserAccountCreateOneInput!
}

input TournamentCreateOneInput {
  create: TournamentCreateInput
  connect: TournamentWhereUniqueInput
}

type TournamentEdge {
  node: Tournament!
  cursor: String!
}

enum TournamentOrderByInput {
  id_ASC
  id_DESC
  season_ASC
  season_DESC
  startDate_ASC
  startDate_DESC
  finishDate_ASC
  finishDate_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TournamentPreviousValues {
  id: ID!
  season: String!
  startDate: DateTime!
  finishDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TournamentSubscriptionPayload {
  mutation: MutationType!
  node: Tournament
  updatedFields: [String!]
  previousValues: TournamentPreviousValues
}

input TournamentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TournamentWhereInput
  AND: [TournamentSubscriptionWhereInput!]
  OR: [TournamentSubscriptionWhereInput!]
  NOT: [TournamentSubscriptionWhereInput!]
}

input TournamentUpdateDataInput {
  game: GameUpdateOneRequiredInput
  season: String
  startDate: DateTime
  finishDate: DateTime
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TournamentUpdateInput {
  game: GameUpdateOneRequiredInput
  season: String
  startDate: DateTime
  finishDate: DateTime
  updatedBy: UserAccountUpdateOneRequiredInput
}

input TournamentUpdateManyMutationInput {
  season: String
  startDate: DateTime
  finishDate: DateTime
}

input TournamentUpdateOneRequiredInput {
  create: TournamentCreateInput
  update: TournamentUpdateDataInput
  upsert: TournamentUpsertNestedInput
  connect: TournamentWhereUniqueInput
}

input TournamentUpsertNestedInput {
  update: TournamentUpdateDataInput!
  create: TournamentCreateInput!
}

input TournamentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  game: GameWhereInput
  season: String
  season_not: String
  season_in: [String!]
  season_not_in: [String!]
  season_lt: String
  season_lte: String
  season_gt: String
  season_gte: String
  season_contains: String
  season_not_contains: String
  season_starts_with: String
  season_not_starts_with: String
  season_ends_with: String
  season_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  finishDate: DateTime
  finishDate_not: DateTime
  finishDate_in: [DateTime!]
  finishDate_not_in: [DateTime!]
  finishDate_lt: DateTime
  finishDate_lte: DateTime
  finishDate_gt: DateTime
  finishDate_gte: DateTime
  updatedBy: UserAccountWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TournamentWhereInput!]
  OR: [TournamentWhereInput!]
  NOT: [TournamentWhereInput!]
}

input TournamentWhereUniqueInput {
  id: ID
}

type UserAccount {
  id: ID!
  employeeId: Employee!
  isActive: Boolean!
  password: String!
  userRole: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAccountConnection {
  pageInfo: PageInfo!
  edges: [UserAccountEdge]!
  aggregate: AggregateUserAccount!
}

input UserAccountCreateInput {
  employeeId: EmployeeCreateOneInput!
  isActive: Boolean!
  password: String!
  userRole: UserRole!
}

input UserAccountCreateOneInput {
  create: UserAccountCreateInput
  connect: UserAccountWhereUniqueInput
}

type UserAccountEdge {
  node: UserAccount!
  cursor: String!
}

enum UserAccountOrderByInput {
  id_ASC
  id_DESC
  isActive_ASC
  isActive_DESC
  password_ASC
  password_DESC
  userRole_ASC
  userRole_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserAccountPreviousValues {
  id: ID!
  isActive: Boolean!
  password: String!
  userRole: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAccountSubscriptionPayload {
  mutation: MutationType!
  node: UserAccount
  updatedFields: [String!]
  previousValues: UserAccountPreviousValues
}

input UserAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAccountWhereInput
  AND: [UserAccountSubscriptionWhereInput!]
  OR: [UserAccountSubscriptionWhereInput!]
  NOT: [UserAccountSubscriptionWhereInput!]
}

type UserAccountToken {
  id: ID!
  user: UserAccount!
  refreshToken: String
}

type UserAccountTokenConnection {
  pageInfo: PageInfo!
  edges: [UserAccountTokenEdge]!
  aggregate: AggregateUserAccountToken!
}

input UserAccountTokenCreateInput {
  user: UserAccountCreateOneInput!
  refreshToken: String
}

type UserAccountTokenEdge {
  node: UserAccountToken!
  cursor: String!
}

enum UserAccountTokenOrderByInput {
  id_ASC
  id_DESC
  refreshToken_ASC
  refreshToken_DESC
}

type UserAccountTokenPreviousValues {
  id: ID!
  refreshToken: String
}

type UserAccountTokenSubscriptionPayload {
  mutation: MutationType!
  node: UserAccountToken
  updatedFields: [String!]
  previousValues: UserAccountTokenPreviousValues
}

input UserAccountTokenSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAccountTokenWhereInput
  AND: [UserAccountTokenSubscriptionWhereInput!]
  OR: [UserAccountTokenSubscriptionWhereInput!]
  NOT: [UserAccountTokenSubscriptionWhereInput!]
}

input UserAccountTokenUpdateInput {
  user: UserAccountUpdateOneRequiredInput
  refreshToken: String
}

input UserAccountTokenUpdateManyMutationInput {
  refreshToken: String
}

input UserAccountTokenWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserAccountWhereInput
  refreshToken: String
  refreshToken_not: String
  refreshToken_in: [String!]
  refreshToken_not_in: [String!]
  refreshToken_lt: String
  refreshToken_lte: String
  refreshToken_gt: String
  refreshToken_gte: String
  refreshToken_contains: String
  refreshToken_not_contains: String
  refreshToken_starts_with: String
  refreshToken_not_starts_with: String
  refreshToken_ends_with: String
  refreshToken_not_ends_with: String
  AND: [UserAccountTokenWhereInput!]
  OR: [UserAccountTokenWhereInput!]
  NOT: [UserAccountTokenWhereInput!]
}

input UserAccountTokenWhereUniqueInput {
  id: ID
}

input UserAccountUpdateDataInput {
  employeeId: EmployeeUpdateOneRequiredInput
  isActive: Boolean
  password: String
  userRole: UserRole
}

input UserAccountUpdateInput {
  employeeId: EmployeeUpdateOneRequiredInput
  isActive: Boolean
  password: String
  userRole: UserRole
}

input UserAccountUpdateManyMutationInput {
  isActive: Boolean
  password: String
  userRole: UserRole
}

input UserAccountUpdateOneRequiredInput {
  create: UserAccountCreateInput
  update: UserAccountUpdateDataInput
  upsert: UserAccountUpsertNestedInput
  connect: UserAccountWhereUniqueInput
}

input UserAccountUpsertNestedInput {
  update: UserAccountUpdateDataInput!
  create: UserAccountCreateInput!
}

input UserAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employeeId: EmployeeWhereInput
  isActive: Boolean
  isActive_not: Boolean
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  userRole: UserRole
  userRole_not: UserRole
  userRole_in: [UserRole!]
  userRole_not_in: [UserRole!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserAccountWhereInput!]
  OR: [UserAccountWhereInput!]
  NOT: [UserAccountWhereInput!]
}

input UserAccountWhereUniqueInput {
  id: ID
}

enum UserRole {
  ADMIN
  USER
}
`