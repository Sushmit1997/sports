// Code generated by Prisma (prisma@1.32.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  carromBoardScore: (where?: CarromBoardScoreWhereInput) => Promise<boolean>;
  carromBoardScoreActivity: (
    where?: CarromBoardScoreActivityWhereInput
  ) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  chessScore: (where?: ChessScoreWhereInput) => Promise<boolean>;
  counterStrikeFScore: (
    where?: CounterStrikeFScoreWhereInput
  ) => Promise<boolean>;
  counterStrikeScoreSet: (
    where?: CounterStrikeScoreSetWhereInput
  ) => Promise<boolean>;
  counterStrikeScoreSetActivity: (
    where?: CounterStrikeScoreSetActivityWhereInput
  ) => Promise<boolean>;
  dotaScore: (where?: DotaScoreWhereInput) => Promise<boolean>;
  dotaScoreActivity: (where?: DotaScoreActivityWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  fixture: (where?: FixtureWhereInput) => Promise<boolean>;
  footballScore: (where?: FootballScoreWhereInput) => Promise<boolean>;
  footballScoreActivity: (
    where?: FootballScoreActivityWhereInput
  ) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  round: (where?: RoundWhereInput) => Promise<boolean>;
  status: (where?: StatusWhereInput) => Promise<boolean>;
  subTournament: (where?: SubTournamentWhereInput) => Promise<boolean>;
  subTournamentPlayer: (
    where?: SubTournamentPlayerWhereInput
  ) => Promise<boolean>;
  tableTennisScore: (where?: TableTennisScoreWhereInput) => Promise<boolean>;
  tableTennisScoreActivity: (
    where?: TableTennisScoreActivityWhereInput
  ) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  teamPlayer: (where?: TeamPlayerWhereInput) => Promise<boolean>;
  tournament: (where?: TournamentWhereInput) => Promise<boolean>;
  userAccount: (where?: UserAccountWhereInput) => Promise<boolean>;
  userAccountToken: (where?: UserAccountTokenWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  carromBoardScore: (
    where: CarromBoardScoreWhereUniqueInput
  ) => CarromBoardScoreNullablePromise;
  carromBoardScores: (args?: {
    where?: CarromBoardScoreWhereInput;
    orderBy?: CarromBoardScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CarromBoardScore>;
  carromBoardScoresConnection: (args?: {
    where?: CarromBoardScoreWhereInput;
    orderBy?: CarromBoardScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CarromBoardScoreConnectionPromise;
  carromBoardScoreActivity: (
    where: CarromBoardScoreActivityWhereUniqueInput
  ) => CarromBoardScoreActivityNullablePromise;
  carromBoardScoreActivities: (args?: {
    where?: CarromBoardScoreActivityWhereInput;
    orderBy?: CarromBoardScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CarromBoardScoreActivity>;
  carromBoardScoreActivitiesConnection: (args?: {
    where?: CarromBoardScoreActivityWhereInput;
    orderBy?: CarromBoardScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CarromBoardScoreActivityConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  chessScore: (where: ChessScoreWhereUniqueInput) => ChessScoreNullablePromise;
  chessScores: (args?: {
    where?: ChessScoreWhereInput;
    orderBy?: ChessScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChessScore>;
  chessScoresConnection: (args?: {
    where?: ChessScoreWhereInput;
    orderBy?: ChessScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChessScoreConnectionPromise;
  counterStrikeFScore: (
    where: CounterStrikeFScoreWhereUniqueInput
  ) => CounterStrikeFScoreNullablePromise;
  counterStrikeFScores: (args?: {
    where?: CounterStrikeFScoreWhereInput;
    orderBy?: CounterStrikeFScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CounterStrikeFScore>;
  counterStrikeFScoresConnection: (args?: {
    where?: CounterStrikeFScoreWhereInput;
    orderBy?: CounterStrikeFScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CounterStrikeFScoreConnectionPromise;
  counterStrikeScoreSet: (
    where: CounterStrikeScoreSetWhereUniqueInput
  ) => CounterStrikeScoreSetNullablePromise;
  counterStrikeScoreSets: (args?: {
    where?: CounterStrikeScoreSetWhereInput;
    orderBy?: CounterStrikeScoreSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CounterStrikeScoreSet>;
  counterStrikeScoreSetsConnection: (args?: {
    where?: CounterStrikeScoreSetWhereInput;
    orderBy?: CounterStrikeScoreSetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CounterStrikeScoreSetConnectionPromise;
  counterStrikeScoreSetActivity: (
    where: CounterStrikeScoreSetActivityWhereUniqueInput
  ) => CounterStrikeScoreSetActivityNullablePromise;
  counterStrikeScoreSetActivities: (args?: {
    where?: CounterStrikeScoreSetActivityWhereInput;
    orderBy?: CounterStrikeScoreSetActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CounterStrikeScoreSetActivity>;
  counterStrikeScoreSetActivitiesConnection: (args?: {
    where?: CounterStrikeScoreSetActivityWhereInput;
    orderBy?: CounterStrikeScoreSetActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CounterStrikeScoreSetActivityConnectionPromise;
  dotaScore: (where: DotaScoreWhereUniqueInput) => DotaScoreNullablePromise;
  dotaScores: (args?: {
    where?: DotaScoreWhereInput;
    orderBy?: DotaScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DotaScore>;
  dotaScoresConnection: (args?: {
    where?: DotaScoreWhereInput;
    orderBy?: DotaScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DotaScoreConnectionPromise;
  dotaScoreActivity: (
    where: DotaScoreActivityWhereUniqueInput
  ) => DotaScoreActivityNullablePromise;
  dotaScoreActivities: (args?: {
    where?: DotaScoreActivityWhereInput;
    orderBy?: DotaScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DotaScoreActivity>;
  dotaScoreActivitiesConnection: (args?: {
    where?: DotaScoreActivityWhereInput;
    orderBy?: DotaScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DotaScoreActivityConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeeNullablePromise;
  employees: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employee>;
  employeesConnection: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeeConnectionPromise;
  fixture: (where: FixtureWhereUniqueInput) => FixtureNullablePromise;
  fixtures: (args?: {
    where?: FixtureWhereInput;
    orderBy?: FixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Fixture>;
  fixturesConnection: (args?: {
    where?: FixtureWhereInput;
    orderBy?: FixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FixtureConnectionPromise;
  footballScore: (
    where: FootballScoreWhereUniqueInput
  ) => FootballScoreNullablePromise;
  footballScores: (args?: {
    where?: FootballScoreWhereInput;
    orderBy?: FootballScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FootballScore>;
  footballScoresConnection: (args?: {
    where?: FootballScoreWhereInput;
    orderBy?: FootballScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FootballScoreConnectionPromise;
  footballScoreActivity: (
    where: FootballScoreActivityWhereUniqueInput
  ) => FootballScoreActivityNullablePromise;
  footballScoreActivities: (args?: {
    where?: FootballScoreActivityWhereInput;
    orderBy?: FootballScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FootballScoreActivity>;
  footballScoreActivitiesConnection: (args?: {
    where?: FootballScoreActivityWhereInput;
    orderBy?: FootballScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FootballScoreActivityConnectionPromise;
  game: (where: GameWhereUniqueInput) => GameNullablePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  round: (where: RoundWhereUniqueInput) => RoundNullablePromise;
  rounds: (args?: {
    where?: RoundWhereInput;
    orderBy?: RoundOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Round>;
  roundsConnection: (args?: {
    where?: RoundWhereInput;
    orderBy?: RoundOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoundConnectionPromise;
  status: (where: StatusWhereUniqueInput) => StatusNullablePromise;
  statuses: (args?: {
    where?: StatusWhereInput;
    orderBy?: StatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Status>;
  statusesConnection: (args?: {
    where?: StatusWhereInput;
    orderBy?: StatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StatusConnectionPromise;
  subTournament: (
    where: SubTournamentWhereUniqueInput
  ) => SubTournamentNullablePromise;
  subTournaments: (args?: {
    where?: SubTournamentWhereInput;
    orderBy?: SubTournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubTournament>;
  subTournamentsConnection: (args?: {
    where?: SubTournamentWhereInput;
    orderBy?: SubTournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubTournamentConnectionPromise;
  subTournamentPlayer: (
    where: SubTournamentPlayerWhereUniqueInput
  ) => SubTournamentPlayerNullablePromise;
  subTournamentPlayers: (args?: {
    where?: SubTournamentPlayerWhereInput;
    orderBy?: SubTournamentPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubTournamentPlayer>;
  subTournamentPlayersConnection: (args?: {
    where?: SubTournamentPlayerWhereInput;
    orderBy?: SubTournamentPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubTournamentPlayerConnectionPromise;
  tableTennisScore: (
    where: TableTennisScoreWhereUniqueInput
  ) => TableTennisScoreNullablePromise;
  tableTennisScores: (args?: {
    where?: TableTennisScoreWhereInput;
    orderBy?: TableTennisScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TableTennisScore>;
  tableTennisScoresConnection: (args?: {
    where?: TableTennisScoreWhereInput;
    orderBy?: TableTennisScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TableTennisScoreConnectionPromise;
  tableTennisScoreActivity: (
    where: TableTennisScoreActivityWhereUniqueInput
  ) => TableTennisScoreActivityNullablePromise;
  tableTennisScoreActivities: (args?: {
    where?: TableTennisScoreActivityWhereInput;
    orderBy?: TableTennisScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TableTennisScoreActivity>;
  tableTennisScoreActivitiesConnection: (args?: {
    where?: TableTennisScoreActivityWhereInput;
    orderBy?: TableTennisScoreActivityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TableTennisScoreActivityConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamNullablePromise;
  teams: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Team>;
  teamsConnection: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamConnectionPromise;
  teamPlayer: (where: TeamPlayerWhereUniqueInput) => TeamPlayerNullablePromise;
  teamPlayers: (args?: {
    where?: TeamPlayerWhereInput;
    orderBy?: TeamPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TeamPlayer>;
  teamPlayersConnection: (args?: {
    where?: TeamPlayerWhereInput;
    orderBy?: TeamPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamPlayerConnectionPromise;
  tournament: (where: TournamentWhereUniqueInput) => TournamentNullablePromise;
  tournaments: (args?: {
    where?: TournamentWhereInput;
    orderBy?: TournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tournament>;
  tournamentsConnection: (args?: {
    where?: TournamentWhereInput;
    orderBy?: TournamentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TournamentConnectionPromise;
  userAccount: (
    where: UserAccountWhereUniqueInput
  ) => UserAccountNullablePromise;
  userAccounts: (args?: {
    where?: UserAccountWhereInput;
    orderBy?: UserAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserAccount>;
  userAccountsConnection: (args?: {
    where?: UserAccountWhereInput;
    orderBy?: UserAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserAccountConnectionPromise;
  userAccountToken: (
    where: UserAccountTokenWhereUniqueInput
  ) => UserAccountTokenNullablePromise;
  userAccountTokens: (args?: {
    where?: UserAccountTokenWhereInput;
    orderBy?: UserAccountTokenOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserAccountToken>;
  userAccountTokensConnection: (args?: {
    where?: UserAccountTokenWhereInput;
    orderBy?: UserAccountTokenOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserAccountTokenConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCarromBoardScore: (
    data: CarromBoardScoreCreateInput
  ) => CarromBoardScorePromise;
  updateCarromBoardScore: (args: {
    data: CarromBoardScoreUpdateInput;
    where: CarromBoardScoreWhereUniqueInput;
  }) => CarromBoardScorePromise;
  updateManyCarromBoardScores: (args: {
    data: CarromBoardScoreUpdateManyMutationInput;
    where?: CarromBoardScoreWhereInput;
  }) => BatchPayloadPromise;
  upsertCarromBoardScore: (args: {
    where: CarromBoardScoreWhereUniqueInput;
    create: CarromBoardScoreCreateInput;
    update: CarromBoardScoreUpdateInput;
  }) => CarromBoardScorePromise;
  deleteCarromBoardScore: (
    where: CarromBoardScoreWhereUniqueInput
  ) => CarromBoardScorePromise;
  deleteManyCarromBoardScores: (
    where?: CarromBoardScoreWhereInput
  ) => BatchPayloadPromise;
  createCarromBoardScoreActivity: (
    data: CarromBoardScoreActivityCreateInput
  ) => CarromBoardScoreActivityPromise;
  updateCarromBoardScoreActivity: (args: {
    data: CarromBoardScoreActivityUpdateInput;
    where: CarromBoardScoreActivityWhereUniqueInput;
  }) => CarromBoardScoreActivityPromise;
  updateManyCarromBoardScoreActivities: (args: {
    data: CarromBoardScoreActivityUpdateManyMutationInput;
    where?: CarromBoardScoreActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertCarromBoardScoreActivity: (args: {
    where: CarromBoardScoreActivityWhereUniqueInput;
    create: CarromBoardScoreActivityCreateInput;
    update: CarromBoardScoreActivityUpdateInput;
  }) => CarromBoardScoreActivityPromise;
  deleteCarromBoardScoreActivity: (
    where: CarromBoardScoreActivityWhereUniqueInput
  ) => CarromBoardScoreActivityPromise;
  deleteManyCarromBoardScoreActivities: (
    where?: CarromBoardScoreActivityWhereInput
  ) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createChessScore: (data: ChessScoreCreateInput) => ChessScorePromise;
  updateChessScore: (args: {
    data: ChessScoreUpdateInput;
    where: ChessScoreWhereUniqueInput;
  }) => ChessScorePromise;
  updateManyChessScores: (args: {
    data: ChessScoreUpdateManyMutationInput;
    where?: ChessScoreWhereInput;
  }) => BatchPayloadPromise;
  upsertChessScore: (args: {
    where: ChessScoreWhereUniqueInput;
    create: ChessScoreCreateInput;
    update: ChessScoreUpdateInput;
  }) => ChessScorePromise;
  deleteChessScore: (where: ChessScoreWhereUniqueInput) => ChessScorePromise;
  deleteManyChessScores: (where?: ChessScoreWhereInput) => BatchPayloadPromise;
  createCounterStrikeFScore: (
    data: CounterStrikeFScoreCreateInput
  ) => CounterStrikeFScorePromise;
  updateCounterStrikeFScore: (args: {
    data: CounterStrikeFScoreUpdateInput;
    where: CounterStrikeFScoreWhereUniqueInput;
  }) => CounterStrikeFScorePromise;
  updateManyCounterStrikeFScores: (args: {
    data: CounterStrikeFScoreUpdateManyMutationInput;
    where?: CounterStrikeFScoreWhereInput;
  }) => BatchPayloadPromise;
  upsertCounterStrikeFScore: (args: {
    where: CounterStrikeFScoreWhereUniqueInput;
    create: CounterStrikeFScoreCreateInput;
    update: CounterStrikeFScoreUpdateInput;
  }) => CounterStrikeFScorePromise;
  deleteCounterStrikeFScore: (
    where: CounterStrikeFScoreWhereUniqueInput
  ) => CounterStrikeFScorePromise;
  deleteManyCounterStrikeFScores: (
    where?: CounterStrikeFScoreWhereInput
  ) => BatchPayloadPromise;
  createCounterStrikeScoreSet: (
    data: CounterStrikeScoreSetCreateInput
  ) => CounterStrikeScoreSetPromise;
  updateCounterStrikeScoreSet: (args: {
    data: CounterStrikeScoreSetUpdateInput;
    where: CounterStrikeScoreSetWhereUniqueInput;
  }) => CounterStrikeScoreSetPromise;
  updateManyCounterStrikeScoreSets: (args: {
    data: CounterStrikeScoreSetUpdateManyMutationInput;
    where?: CounterStrikeScoreSetWhereInput;
  }) => BatchPayloadPromise;
  upsertCounterStrikeScoreSet: (args: {
    where: CounterStrikeScoreSetWhereUniqueInput;
    create: CounterStrikeScoreSetCreateInput;
    update: CounterStrikeScoreSetUpdateInput;
  }) => CounterStrikeScoreSetPromise;
  deleteCounterStrikeScoreSet: (
    where: CounterStrikeScoreSetWhereUniqueInput
  ) => CounterStrikeScoreSetPromise;
  deleteManyCounterStrikeScoreSets: (
    where?: CounterStrikeScoreSetWhereInput
  ) => BatchPayloadPromise;
  createCounterStrikeScoreSetActivity: (
    data: CounterStrikeScoreSetActivityCreateInput
  ) => CounterStrikeScoreSetActivityPromise;
  updateCounterStrikeScoreSetActivity: (args: {
    data: CounterStrikeScoreSetActivityUpdateInput;
    where: CounterStrikeScoreSetActivityWhereUniqueInput;
  }) => CounterStrikeScoreSetActivityPromise;
  updateManyCounterStrikeScoreSetActivities: (args: {
    data: CounterStrikeScoreSetActivityUpdateManyMutationInput;
    where?: CounterStrikeScoreSetActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertCounterStrikeScoreSetActivity: (args: {
    where: CounterStrikeScoreSetActivityWhereUniqueInput;
    create: CounterStrikeScoreSetActivityCreateInput;
    update: CounterStrikeScoreSetActivityUpdateInput;
  }) => CounterStrikeScoreSetActivityPromise;
  deleteCounterStrikeScoreSetActivity: (
    where: CounterStrikeScoreSetActivityWhereUniqueInput
  ) => CounterStrikeScoreSetActivityPromise;
  deleteManyCounterStrikeScoreSetActivities: (
    where?: CounterStrikeScoreSetActivityWhereInput
  ) => BatchPayloadPromise;
  createDotaScore: (data: DotaScoreCreateInput) => DotaScorePromise;
  updateDotaScore: (args: {
    data: DotaScoreUpdateInput;
    where: DotaScoreWhereUniqueInput;
  }) => DotaScorePromise;
  updateManyDotaScores: (args: {
    data: DotaScoreUpdateManyMutationInput;
    where?: DotaScoreWhereInput;
  }) => BatchPayloadPromise;
  upsertDotaScore: (args: {
    where: DotaScoreWhereUniqueInput;
    create: DotaScoreCreateInput;
    update: DotaScoreUpdateInput;
  }) => DotaScorePromise;
  deleteDotaScore: (where: DotaScoreWhereUniqueInput) => DotaScorePromise;
  deleteManyDotaScores: (where?: DotaScoreWhereInput) => BatchPayloadPromise;
  createDotaScoreActivity: (
    data: DotaScoreActivityCreateInput
  ) => DotaScoreActivityPromise;
  updateDotaScoreActivity: (args: {
    data: DotaScoreActivityUpdateInput;
    where: DotaScoreActivityWhereUniqueInput;
  }) => DotaScoreActivityPromise;
  updateManyDotaScoreActivities: (args: {
    data: DotaScoreActivityUpdateManyMutationInput;
    where?: DotaScoreActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertDotaScoreActivity: (args: {
    where: DotaScoreActivityWhereUniqueInput;
    create: DotaScoreActivityCreateInput;
    update: DotaScoreActivityUpdateInput;
  }) => DotaScoreActivityPromise;
  deleteDotaScoreActivity: (
    where: DotaScoreActivityWhereUniqueInput
  ) => DotaScoreActivityPromise;
  deleteManyDotaScoreActivities: (
    where?: DotaScoreActivityWhereInput
  ) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (args: {
    data: EmployeeUpdateInput;
    where: EmployeeWhereUniqueInput;
  }) => EmployeePromise;
  updateManyEmployees: (args: {
    data: EmployeeUpdateManyMutationInput;
    where?: EmployeeWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployee: (args: {
    where: EmployeeWhereUniqueInput;
    create: EmployeeCreateInput;
    update: EmployeeUpdateInput;
  }) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createFixture: (data: FixtureCreateInput) => FixturePromise;
  updateFixture: (args: {
    data: FixtureUpdateInput;
    where: FixtureWhereUniqueInput;
  }) => FixturePromise;
  updateManyFixtures: (args: {
    data: FixtureUpdateManyMutationInput;
    where?: FixtureWhereInput;
  }) => BatchPayloadPromise;
  upsertFixture: (args: {
    where: FixtureWhereUniqueInput;
    create: FixtureCreateInput;
    update: FixtureUpdateInput;
  }) => FixturePromise;
  deleteFixture: (where: FixtureWhereUniqueInput) => FixturePromise;
  deleteManyFixtures: (where?: FixtureWhereInput) => BatchPayloadPromise;
  createFootballScore: (data: FootballScoreCreateInput) => FootballScorePromise;
  updateFootballScore: (args: {
    data: FootballScoreUpdateInput;
    where: FootballScoreWhereUniqueInput;
  }) => FootballScorePromise;
  updateManyFootballScores: (args: {
    data: FootballScoreUpdateManyMutationInput;
    where?: FootballScoreWhereInput;
  }) => BatchPayloadPromise;
  upsertFootballScore: (args: {
    where: FootballScoreWhereUniqueInput;
    create: FootballScoreCreateInput;
    update: FootballScoreUpdateInput;
  }) => FootballScorePromise;
  deleteFootballScore: (
    where: FootballScoreWhereUniqueInput
  ) => FootballScorePromise;
  deleteManyFootballScores: (
    where?: FootballScoreWhereInput
  ) => BatchPayloadPromise;
  createFootballScoreActivity: (
    data: FootballScoreActivityCreateInput
  ) => FootballScoreActivityPromise;
  updateFootballScoreActivity: (args: {
    data: FootballScoreActivityUpdateInput;
    where: FootballScoreActivityWhereUniqueInput;
  }) => FootballScoreActivityPromise;
  updateManyFootballScoreActivities: (args: {
    data: FootballScoreActivityUpdateManyMutationInput;
    where?: FootballScoreActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertFootballScoreActivity: (args: {
    where: FootballScoreActivityWhereUniqueInput;
    create: FootballScoreActivityCreateInput;
    update: FootballScoreActivityUpdateInput;
  }) => FootballScoreActivityPromise;
  deleteFootballScoreActivity: (
    where: FootballScoreActivityWhereUniqueInput
  ) => FootballScoreActivityPromise;
  deleteManyFootballScoreActivities: (
    where?: FootballScoreActivityWhereInput
  ) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createRound: (data: RoundCreateInput) => RoundPromise;
  updateRound: (args: {
    data: RoundUpdateInput;
    where: RoundWhereUniqueInput;
  }) => RoundPromise;
  updateManyRounds: (args: {
    data: RoundUpdateManyMutationInput;
    where?: RoundWhereInput;
  }) => BatchPayloadPromise;
  upsertRound: (args: {
    where: RoundWhereUniqueInput;
    create: RoundCreateInput;
    update: RoundUpdateInput;
  }) => RoundPromise;
  deleteRound: (where: RoundWhereUniqueInput) => RoundPromise;
  deleteManyRounds: (where?: RoundWhereInput) => BatchPayloadPromise;
  createStatus: (data: StatusCreateInput) => StatusPromise;
  updateStatus: (args: {
    data: StatusUpdateInput;
    where: StatusWhereUniqueInput;
  }) => StatusPromise;
  updateManyStatuses: (args: {
    data: StatusUpdateManyMutationInput;
    where?: StatusWhereInput;
  }) => BatchPayloadPromise;
  upsertStatus: (args: {
    where: StatusWhereUniqueInput;
    create: StatusCreateInput;
    update: StatusUpdateInput;
  }) => StatusPromise;
  deleteStatus: (where: StatusWhereUniqueInput) => StatusPromise;
  deleteManyStatuses: (where?: StatusWhereInput) => BatchPayloadPromise;
  createSubTournament: (data: SubTournamentCreateInput) => SubTournamentPromise;
  updateSubTournament: (args: {
    data: SubTournamentUpdateInput;
    where: SubTournamentWhereUniqueInput;
  }) => SubTournamentPromise;
  upsertSubTournament: (args: {
    where: SubTournamentWhereUniqueInput;
    create: SubTournamentCreateInput;
    update: SubTournamentUpdateInput;
  }) => SubTournamentPromise;
  deleteSubTournament: (
    where: SubTournamentWhereUniqueInput
  ) => SubTournamentPromise;
  deleteManySubTournaments: (
    where?: SubTournamentWhereInput
  ) => BatchPayloadPromise;
  createSubTournamentPlayer: (
    data: SubTournamentPlayerCreateInput
  ) => SubTournamentPlayerPromise;
  updateSubTournamentPlayer: (args: {
    data: SubTournamentPlayerUpdateInput;
    where: SubTournamentPlayerWhereUniqueInput;
  }) => SubTournamentPlayerPromise;
  updateManySubTournamentPlayers: (args: {
    data: SubTournamentPlayerUpdateManyMutationInput;
    where?: SubTournamentPlayerWhereInput;
  }) => BatchPayloadPromise;
  upsertSubTournamentPlayer: (args: {
    where: SubTournamentPlayerWhereUniqueInput;
    create: SubTournamentPlayerCreateInput;
    update: SubTournamentPlayerUpdateInput;
  }) => SubTournamentPlayerPromise;
  deleteSubTournamentPlayer: (
    where: SubTournamentPlayerWhereUniqueInput
  ) => SubTournamentPlayerPromise;
  deleteManySubTournamentPlayers: (
    where?: SubTournamentPlayerWhereInput
  ) => BatchPayloadPromise;
  createTableTennisScore: (
    data: TableTennisScoreCreateInput
  ) => TableTennisScorePromise;
  updateTableTennisScore: (args: {
    data: TableTennisScoreUpdateInput;
    where: TableTennisScoreWhereUniqueInput;
  }) => TableTennisScorePromise;
  updateManyTableTennisScores: (args: {
    data: TableTennisScoreUpdateManyMutationInput;
    where?: TableTennisScoreWhereInput;
  }) => BatchPayloadPromise;
  upsertTableTennisScore: (args: {
    where: TableTennisScoreWhereUniqueInput;
    create: TableTennisScoreCreateInput;
    update: TableTennisScoreUpdateInput;
  }) => TableTennisScorePromise;
  deleteTableTennisScore: (
    where: TableTennisScoreWhereUniqueInput
  ) => TableTennisScorePromise;
  deleteManyTableTennisScores: (
    where?: TableTennisScoreWhereInput
  ) => BatchPayloadPromise;
  createTableTennisScoreActivity: (
    data: TableTennisScoreActivityCreateInput
  ) => TableTennisScoreActivityPromise;
  updateTableTennisScoreActivity: (args: {
    data: TableTennisScoreActivityUpdateInput;
    where: TableTennisScoreActivityWhereUniqueInput;
  }) => TableTennisScoreActivityPromise;
  updateManyTableTennisScoreActivities: (args: {
    data: TableTennisScoreActivityUpdateManyMutationInput;
    where?: TableTennisScoreActivityWhereInput;
  }) => BatchPayloadPromise;
  upsertTableTennisScoreActivity: (args: {
    where: TableTennisScoreActivityWhereUniqueInput;
    create: TableTennisScoreActivityCreateInput;
    update: TableTennisScoreActivityUpdateInput;
  }) => TableTennisScoreActivityPromise;
  deleteTableTennisScoreActivity: (
    where: TableTennisScoreActivityWhereUniqueInput
  ) => TableTennisScoreActivityPromise;
  deleteManyTableTennisScoreActivities: (
    where?: TableTennisScoreActivityWhereInput
  ) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (args: {
    data: TeamUpdateInput;
    where: TeamWhereUniqueInput;
  }) => TeamPromise;
  updateManyTeams: (args: {
    data: TeamUpdateManyMutationInput;
    where?: TeamWhereInput;
  }) => BatchPayloadPromise;
  upsertTeam: (args: {
    where: TeamWhereUniqueInput;
    create: TeamCreateInput;
    update: TeamUpdateInput;
  }) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;
  createTeamPlayer: (data: TeamPlayerCreateInput) => TeamPlayerPromise;
  updateTeamPlayer: (args: {
    data: TeamPlayerUpdateInput;
    where: TeamPlayerWhereUniqueInput;
  }) => TeamPlayerPromise;
  updateManyTeamPlayers: (args: {
    data: TeamPlayerUpdateManyMutationInput;
    where?: TeamPlayerWhereInput;
  }) => BatchPayloadPromise;
  upsertTeamPlayer: (args: {
    where: TeamPlayerWhereUniqueInput;
    create: TeamPlayerCreateInput;
    update: TeamPlayerUpdateInput;
  }) => TeamPlayerPromise;
  deleteTeamPlayer: (where: TeamPlayerWhereUniqueInput) => TeamPlayerPromise;
  deleteManyTeamPlayers: (where?: TeamPlayerWhereInput) => BatchPayloadPromise;
  createTournament: (data: TournamentCreateInput) => TournamentPromise;
  updateTournament: (args: {
    data: TournamentUpdateInput;
    where: TournamentWhereUniqueInput;
  }) => TournamentPromise;
  updateManyTournaments: (args: {
    data: TournamentUpdateManyMutationInput;
    where?: TournamentWhereInput;
  }) => BatchPayloadPromise;
  upsertTournament: (args: {
    where: TournamentWhereUniqueInput;
    create: TournamentCreateInput;
    update: TournamentUpdateInput;
  }) => TournamentPromise;
  deleteTournament: (where: TournamentWhereUniqueInput) => TournamentPromise;
  deleteManyTournaments: (where?: TournamentWhereInput) => BatchPayloadPromise;
  createUserAccount: (data: UserAccountCreateInput) => UserAccountPromise;
  updateUserAccount: (args: {
    data: UserAccountUpdateInput;
    where: UserAccountWhereUniqueInput;
  }) => UserAccountPromise;
  updateManyUserAccounts: (args: {
    data: UserAccountUpdateManyMutationInput;
    where?: UserAccountWhereInput;
  }) => BatchPayloadPromise;
  upsertUserAccount: (args: {
    where: UserAccountWhereUniqueInput;
    create: UserAccountCreateInput;
    update: UserAccountUpdateInput;
  }) => UserAccountPromise;
  deleteUserAccount: (where: UserAccountWhereUniqueInput) => UserAccountPromise;
  deleteManyUserAccounts: (
    where?: UserAccountWhereInput
  ) => BatchPayloadPromise;
  createUserAccountToken: (
    data: UserAccountTokenCreateInput
  ) => UserAccountTokenPromise;
  updateUserAccountToken: (args: {
    data: UserAccountTokenUpdateInput;
    where: UserAccountTokenWhereUniqueInput;
  }) => UserAccountTokenPromise;
  updateManyUserAccountTokens: (args: {
    data: UserAccountTokenUpdateManyMutationInput;
    where?: UserAccountTokenWhereInput;
  }) => BatchPayloadPromise;
  upsertUserAccountToken: (args: {
    where: UserAccountTokenWhereUniqueInput;
    create: UserAccountTokenCreateInput;
    update: UserAccountTokenUpdateInput;
  }) => UserAccountTokenPromise;
  deleteUserAccountToken: (
    where: UserAccountTokenWhereUniqueInput
  ) => UserAccountTokenPromise;
  deleteManyUserAccountTokens: (
    where?: UserAccountTokenWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  carromBoardScore: (
    where?: CarromBoardScoreSubscriptionWhereInput
  ) => CarromBoardScoreSubscriptionPayloadSubscription;
  carromBoardScoreActivity: (
    where?: CarromBoardScoreActivitySubscriptionWhereInput
  ) => CarromBoardScoreActivitySubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  chessScore: (
    where?: ChessScoreSubscriptionWhereInput
  ) => ChessScoreSubscriptionPayloadSubscription;
  counterStrikeFScore: (
    where?: CounterStrikeFScoreSubscriptionWhereInput
  ) => CounterStrikeFScoreSubscriptionPayloadSubscription;
  counterStrikeScoreSet: (
    where?: CounterStrikeScoreSetSubscriptionWhereInput
  ) => CounterStrikeScoreSetSubscriptionPayloadSubscription;
  counterStrikeScoreSetActivity: (
    where?: CounterStrikeScoreSetActivitySubscriptionWhereInput
  ) => CounterStrikeScoreSetActivitySubscriptionPayloadSubscription;
  dotaScore: (
    where?: DotaScoreSubscriptionWhereInput
  ) => DotaScoreSubscriptionPayloadSubscription;
  dotaScoreActivity: (
    where?: DotaScoreActivitySubscriptionWhereInput
  ) => DotaScoreActivitySubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  fixture: (
    where?: FixtureSubscriptionWhereInput
  ) => FixtureSubscriptionPayloadSubscription;
  footballScore: (
    where?: FootballScoreSubscriptionWhereInput
  ) => FootballScoreSubscriptionPayloadSubscription;
  footballScoreActivity: (
    where?: FootballScoreActivitySubscriptionWhereInput
  ) => FootballScoreActivitySubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  round: (
    where?: RoundSubscriptionWhereInput
  ) => RoundSubscriptionPayloadSubscription;
  status: (
    where?: StatusSubscriptionWhereInput
  ) => StatusSubscriptionPayloadSubscription;
  subTournament: (
    where?: SubTournamentSubscriptionWhereInput
  ) => SubTournamentSubscriptionPayloadSubscription;
  subTournamentPlayer: (
    where?: SubTournamentPlayerSubscriptionWhereInput
  ) => SubTournamentPlayerSubscriptionPayloadSubscription;
  tableTennisScore: (
    where?: TableTennisScoreSubscriptionWhereInput
  ) => TableTennisScoreSubscriptionPayloadSubscription;
  tableTennisScoreActivity: (
    where?: TableTennisScoreActivitySubscriptionWhereInput
  ) => TableTennisScoreActivitySubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
  teamPlayer: (
    where?: TeamPlayerSubscriptionWhereInput
  ) => TeamPlayerSubscriptionPayloadSubscription;
  tournament: (
    where?: TournamentSubscriptionWhereInput
  ) => TournamentSubscriptionPayloadSubscription;
  userAccount: (
    where?: UserAccountSubscriptionWhereInput
  ) => UserAccountSubscriptionPayloadSubscription;
  userAccountToken: (
    where?: UserAccountTokenSubscriptionWhereInput
  ) => UserAccountTokenSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FootballScoreActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "activityType_ASC"
  | "activityType_DESC"
  | "activityTime_ASC"
  | "activityTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CarromBoardScoreActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "points_ASC"
  | "points_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FootballActivityType =
  | "GOAL"
  | "OWN_GOAL"
  | "RED_CARD"
  | "YELLOW_CARD"
  | "DOUBLE_YELLOW_CARD";

export type UserAccountTokenOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC";

export type FootballScoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "homeTeamFTScore_ASC"
  | "homeTeamFTScore_DESC"
  | "awayTeamFTScore_ASC"
  | "awayTeamFTScore_DESC"
  | "homeTeamAetScore_ASC"
  | "homeTeamAetScore_DESC"
  | "awayTeamAetScore_ASC"
  | "awayTeamAetScore_DESC"
  | "homeTeamPenaltyScore_ASC"
  | "homeTeamPenaltyScore_DESC"
  | "awayTeamPenaltyScore_ASC"
  | "awayTeamPenaltyScore_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TournamentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "season_ASC"
  | "season_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "finishDate_ASC"
  | "finishDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FixtureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "logoImage_ASC"
  | "logoImage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmployeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "middleName_ASC"
  | "middleName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "profilePictureUrl_ASC"
  | "profilePictureUrl_DESC"
  | "lmsEmpId_ASC"
  | "lmsEmpId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TableTennisScoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "homeTeamScore_ASC"
  | "homeTeamScore_DESC"
  | "awayTeamScore_ASC"
  | "awayTeamScore_DESC"
  | "setsCount_ASC"
  | "setsCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DotaScoreActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "set_ASC"
  | "set_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubTournamentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DotaScoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "setsCount_ASC"
  | "setsCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRole = "ADMIN" | "USER";

export type CounterStrikeScoreSetActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "kills_ASC"
  | "kills_DESC"
  | "deaths_ASC"
  | "deaths_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CounterStrikeScoreSetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "set_ASC"
  | "set_DESC"
  | "homeTeamScore_ASC"
  | "homeTeamScore_DESC"
  | "awayTeamScore_ASC"
  | "awayTeamScore_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "password_ASC"
  | "password_DESC"
  | "userRole_ASC"
  | "userRole_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CounterStrikeFScoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "homeTeamScore_ASC"
  | "homeTeamScore_DESC"
  | "awayTeamScore_ASC"
  | "awayTeamScore_DESC"
  | "setsCount_ASC"
  | "setsCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TableTennisScoreActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "set_ASC"
  | "set_DESC"
  | "homeTeamPoints_ASC"
  | "homeTeamPoints_DESC"
  | "awayTeamPoints_ASC"
  | "awayTeamPoints_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CarromBoardScoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "homeTeamScore_ASC"
  | "homeTeamScore_DESC"
  | "awayTeamScore_ASC"
  | "awayTeamScore_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ChessWinningMethod = "TIME" | "CHECKMATE";

export type ChessScoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "winningMethod_ASC"
  | "winningMethod_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubTournamentPlayerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "position_ASC"
  | "position_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TeamPlayerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isCaptain_ASC"
  | "isCaptain_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type RoundOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "sortOrder_ASC"
  | "sortOrder_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface StatusCreateInput {
  name: String;
  updatedBy: UserAccountCreateOneInput;
}

export type CarromBoardScoreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DotaScoreCreateInput {
  fixture: FixtureCreateOneInput;
  setsCount: Int;
  winnerTeam?: Maybe<TeamCreateOneInput>;
  updatedBy: UserAccountCreateOneInput;
}

export interface FixtureUpdateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface CounterStrikeScoreSetActivityUpdateManyMutationInput {
  kills?: Maybe<Int>;
  deaths?: Maybe<Int>;
}

export interface TournamentUpdateDataInput {
  game?: Maybe<GameUpdateOneRequiredInput>;
  season?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  finishDate?: Maybe<DateTimeInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface TeamPlayerUpsertNestedInput {
  update: TeamPlayerUpdateDataInput;
  create: TeamPlayerCreateInput;
}

export type CarromBoardScoreActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SubTournamentPlayerUpsertNestedInput {
  update: SubTournamentPlayerUpdateDataInput;
  create: SubTournamentPlayerCreateInput;
}

export interface CarromBoardScoreActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  team?: Maybe<TeamWhereInput>;
  points?: Maybe<Int>;
  points_not?: Maybe<Int>;
  points_in?: Maybe<Int[] | Int>;
  points_not_in?: Maybe<Int[] | Int>;
  points_lt?: Maybe<Int>;
  points_lte?: Maybe<Int>;
  points_gt?: Maybe<Int>;
  points_gte?: Maybe<Int>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CarromBoardScoreActivityWhereInput[] | CarromBoardScoreActivityWhereInput
  >;
  OR?: Maybe<
    CarromBoardScoreActivityWhereInput[] | CarromBoardScoreActivityWhereInput
  >;
  NOT?: Maybe<
    CarromBoardScoreActivityWhereInput[] | CarromBoardScoreActivityWhereInput
  >;
}

export type TableTennisScoreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamPlayerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TeamPlayerWhereInput>;
  AND?: Maybe<
    TeamPlayerSubscriptionWhereInput[] | TeamPlayerSubscriptionWhereInput
  >;
  OR?: Maybe<
    TeamPlayerSubscriptionWhereInput[] | TeamPlayerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TeamPlayerSubscriptionWhereInput[] | TeamPlayerSubscriptionWhereInput
  >;
}

export interface SubTournamentPlayerUpdateDataInput {
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  player?: Maybe<EmployeeUpdateOneRequiredInput>;
  position?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface TableTennisScoreActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TableTennisScoreActivityWhereInput>;
  AND?: Maybe<
    | TableTennisScoreActivitySubscriptionWhereInput[]
    | TableTennisScoreActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | TableTennisScoreActivitySubscriptionWhereInput[]
    | TableTennisScoreActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TableTennisScoreActivitySubscriptionWhereInput[]
    | TableTennisScoreActivitySubscriptionWhereInput
  >;
}

export interface TableTennisScoreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  homeTeamScore?: Maybe<Int>;
  homeTeamScore_not?: Maybe<Int>;
  homeTeamScore_in?: Maybe<Int[] | Int>;
  homeTeamScore_not_in?: Maybe<Int[] | Int>;
  homeTeamScore_lt?: Maybe<Int>;
  homeTeamScore_lte?: Maybe<Int>;
  homeTeamScore_gt?: Maybe<Int>;
  homeTeamScore_gte?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  awayTeamScore_not?: Maybe<Int>;
  awayTeamScore_in?: Maybe<Int[] | Int>;
  awayTeamScore_not_in?: Maybe<Int[] | Int>;
  awayTeamScore_lt?: Maybe<Int>;
  awayTeamScore_lte?: Maybe<Int>;
  awayTeamScore_gt?: Maybe<Int>;
  awayTeamScore_gte?: Maybe<Int>;
  setsCount?: Maybe<Int>;
  setsCount_not?: Maybe<Int>;
  setsCount_in?: Maybe<Int[] | Int>;
  setsCount_not_in?: Maybe<Int[] | Int>;
  setsCount_lt?: Maybe<Int>;
  setsCount_lte?: Maybe<Int>;
  setsCount_gt?: Maybe<Int>;
  setsCount_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TableTennisScoreWhereInput[] | TableTennisScoreWhereInput>;
  OR?: Maybe<TableTennisScoreWhereInput[] | TableTennisScoreWhereInput>;
  NOT?: Maybe<TableTennisScoreWhereInput[] | TableTennisScoreWhereInput>;
}

export interface RoundWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  sortOrder?: Maybe<Int>;
  sortOrder_not?: Maybe<Int>;
  sortOrder_in?: Maybe<Int[] | Int>;
  sortOrder_not_in?: Maybe<Int[] | Int>;
  sortOrder_lt?: Maybe<Int>;
  sortOrder_lte?: Maybe<Int>;
  sortOrder_gt?: Maybe<Int>;
  sortOrder_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RoundWhereInput[] | RoundWhereInput>;
  OR?: Maybe<RoundWhereInput[] | RoundWhereInput>;
  NOT?: Maybe<RoundWhereInput[] | RoundWhereInput>;
}

export interface SubTournamentPlayerUpdateOneRequiredInput {
  create?: Maybe<SubTournamentPlayerCreateInput>;
  update?: Maybe<SubTournamentPlayerUpdateDataInput>;
  upsert?: Maybe<SubTournamentPlayerUpsertNestedInput>;
  connect?: Maybe<SubTournamentPlayerWhereUniqueInput>;
}

export interface SubTournamentPlayerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubTournamentPlayerWhereInput>;
  AND?: Maybe<
    | SubTournamentPlayerSubscriptionWhereInput[]
    | SubTournamentPlayerSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SubTournamentPlayerSubscriptionWhereInput[]
    | SubTournamentPlayerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SubTournamentPlayerSubscriptionWhereInput[]
    | SubTournamentPlayerSubscriptionWhereInput
  >;
}

export interface TeamPlayerUpdateDataInput {
  team?: Maybe<TeamUpdateOneRequiredInput>;
  player?: Maybe<SubTournamentPlayerUpdateOneRequiredInput>;
  isCaptain?: Maybe<Boolean>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export type ChessScoreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamPlayerUpdateOneRequiredInput {
  create?: Maybe<TeamPlayerCreateInput>;
  update?: Maybe<TeamPlayerUpdateDataInput>;
  upsert?: Maybe<TeamPlayerUpsertNestedInput>;
  connect?: Maybe<TeamPlayerWhereUniqueInput>;
}

export interface TeamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  logoImage?: Maybe<String>;
  logoImage_not?: Maybe<String>;
  logoImage_in?: Maybe<String[] | String>;
  logoImage_not_in?: Maybe<String[] | String>;
  logoImage_lt?: Maybe<String>;
  logoImage_lte?: Maybe<String>;
  logoImage_gt?: Maybe<String>;
  logoImage_gte?: Maybe<String>;
  logoImage_contains?: Maybe<String>;
  logoImage_not_contains?: Maybe<String>;
  logoImage_starts_with?: Maybe<String>;
  logoImage_not_starts_with?: Maybe<String>;
  logoImage_ends_with?: Maybe<String>;
  logoImage_not_ends_with?: Maybe<String>;
  subTournament?: Maybe<SubTournamentWhereInput>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  OR?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  NOT?: Maybe<TeamWhereInput[] | TeamWhereInput>;
}

export interface CounterStrikeScoreSetUpsertNestedInput {
  update: CounterStrikeScoreSetUpdateDataInput;
  create: CounterStrikeScoreSetCreateInput;
}

export interface StatusWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StatusWhereInput[] | StatusWhereInput>;
  OR?: Maybe<StatusWhereInput[] | StatusWhereInput>;
  NOT?: Maybe<StatusWhereInput[] | StatusWhereInput>;
}

export type TableTennisScoreActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameWhereInput>;
  AND?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
  OR?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
  NOT?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
}

export interface CounterStrikeScoreSetUpdateDataInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  set?: Maybe<Int>;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export type CounterStrikeFScoreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TableTennisScoreActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  set?: Maybe<Int>;
  set_not?: Maybe<Int>;
  set_in?: Maybe<Int[] | Int>;
  set_not_in?: Maybe<Int[] | Int>;
  set_lt?: Maybe<Int>;
  set_lte?: Maybe<Int>;
  set_gt?: Maybe<Int>;
  set_gte?: Maybe<Int>;
  homeTeamPoints?: Maybe<Int>;
  homeTeamPoints_not?: Maybe<Int>;
  homeTeamPoints_in?: Maybe<Int[] | Int>;
  homeTeamPoints_not_in?: Maybe<Int[] | Int>;
  homeTeamPoints_lt?: Maybe<Int>;
  homeTeamPoints_lte?: Maybe<Int>;
  homeTeamPoints_gt?: Maybe<Int>;
  homeTeamPoints_gte?: Maybe<Int>;
  awayTeamPoints?: Maybe<Int>;
  awayTeamPoints_not?: Maybe<Int>;
  awayTeamPoints_in?: Maybe<Int[] | Int>;
  awayTeamPoints_not_in?: Maybe<Int[] | Int>;
  awayTeamPoints_lt?: Maybe<Int>;
  awayTeamPoints_lte?: Maybe<Int>;
  awayTeamPoints_gt?: Maybe<Int>;
  awayTeamPoints_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    TableTennisScoreActivityWhereInput[] | TableTennisScoreActivityWhereInput
  >;
  OR?: Maybe<
    TableTennisScoreActivityWhereInput[] | TableTennisScoreActivityWhereInput
  >;
  NOT?: Maybe<
    TableTennisScoreActivityWhereInput[] | TableTennisScoreActivityWhereInput
  >;
}

export interface CounterStrikeFScoreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  homeTeamScore?: Maybe<Int>;
  homeTeamScore_not?: Maybe<Int>;
  homeTeamScore_in?: Maybe<Int[] | Int>;
  homeTeamScore_not_in?: Maybe<Int[] | Int>;
  homeTeamScore_lt?: Maybe<Int>;
  homeTeamScore_lte?: Maybe<Int>;
  homeTeamScore_gt?: Maybe<Int>;
  homeTeamScore_gte?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  awayTeamScore_not?: Maybe<Int>;
  awayTeamScore_in?: Maybe<Int[] | Int>;
  awayTeamScore_not_in?: Maybe<Int[] | Int>;
  awayTeamScore_lt?: Maybe<Int>;
  awayTeamScore_lte?: Maybe<Int>;
  awayTeamScore_gt?: Maybe<Int>;
  awayTeamScore_gte?: Maybe<Int>;
  setsCount?: Maybe<Int>;
  setsCount_not?: Maybe<Int>;
  setsCount_in?: Maybe<Int[] | Int>;
  setsCount_not_in?: Maybe<Int[] | Int>;
  setsCount_lt?: Maybe<Int>;
  setsCount_lte?: Maybe<Int>;
  setsCount_gt?: Maybe<Int>;
  setsCount_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CounterStrikeFScoreWhereInput[] | CounterStrikeFScoreWhereInput>;
  OR?: Maybe<CounterStrikeFScoreWhereInput[] | CounterStrikeFScoreWhereInput>;
  NOT?: Maybe<CounterStrikeFScoreWhereInput[] | CounterStrikeFScoreWhereInput>;
}

export interface CounterStrikeScoreSetUpdateOneRequiredInput {
  create?: Maybe<CounterStrikeScoreSetCreateInput>;
  update?: Maybe<CounterStrikeScoreSetUpdateDataInput>;
  upsert?: Maybe<CounterStrikeScoreSetUpsertNestedInput>;
  connect?: Maybe<CounterStrikeScoreSetWhereUniqueInput>;
}

export interface FixtureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FixtureWhereInput>;
  AND?: Maybe<FixtureSubscriptionWhereInput[] | FixtureSubscriptionWhereInput>;
  OR?: Maybe<FixtureSubscriptionWhereInput[] | FixtureSubscriptionWhereInput>;
  NOT?: Maybe<FixtureSubscriptionWhereInput[] | FixtureSubscriptionWhereInput>;
}

export interface CounterStrikeScoreSetActivityUpdateInput {
  set?: Maybe<CounterStrikeScoreSetUpdateOneRequiredInput>;
  teamPlayer?: Maybe<TeamPlayerUpdateOneRequiredInput>;
  kills?: Maybe<Int>;
  deaths?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface DotaScoreActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DotaScoreActivityWhereInput>;
  AND?: Maybe<
    | DotaScoreActivitySubscriptionWhereInput[]
    | DotaScoreActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | DotaScoreActivitySubscriptionWhereInput[]
    | DotaScoreActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DotaScoreActivitySubscriptionWhereInput[]
    | DotaScoreActivitySubscriptionWhereInput
  >;
}

export interface SubTournamentPlayerCreateInput {
  subTournament: SubTournamentCreateOneInput;
  player: EmployeeCreateOneInput;
  position?: Maybe<String>;
  updatedBy: UserAccountCreateOneInput;
}

export interface DotaScoreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DotaScoreWhereInput>;
  AND?: Maybe<
    DotaScoreSubscriptionWhereInput[] | DotaScoreSubscriptionWhereInput
  >;
  OR?: Maybe<
    DotaScoreSubscriptionWhereInput[] | DotaScoreSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DotaScoreSubscriptionWhereInput[] | DotaScoreSubscriptionWhereInput
  >;
}

export interface SubTournamentPlayerCreateOneInput {
  create?: Maybe<SubTournamentPlayerCreateInput>;
  connect?: Maybe<SubTournamentPlayerWhereUniqueInput>;
}

export interface EmployeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  middleName?: Maybe<String>;
  middleName_not?: Maybe<String>;
  middleName_in?: Maybe<String[] | String>;
  middleName_not_in?: Maybe<String[] | String>;
  middleName_lt?: Maybe<String>;
  middleName_lte?: Maybe<String>;
  middleName_gt?: Maybe<String>;
  middleName_gte?: Maybe<String>;
  middleName_contains?: Maybe<String>;
  middleName_not_contains?: Maybe<String>;
  middleName_starts_with?: Maybe<String>;
  middleName_not_starts_with?: Maybe<String>;
  middleName_ends_with?: Maybe<String>;
  middleName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  profilePictureUrl?: Maybe<String>;
  profilePictureUrl_not?: Maybe<String>;
  profilePictureUrl_in?: Maybe<String[] | String>;
  profilePictureUrl_not_in?: Maybe<String[] | String>;
  profilePictureUrl_lt?: Maybe<String>;
  profilePictureUrl_lte?: Maybe<String>;
  profilePictureUrl_gt?: Maybe<String>;
  profilePictureUrl_gte?: Maybe<String>;
  profilePictureUrl_contains?: Maybe<String>;
  profilePictureUrl_not_contains?: Maybe<String>;
  profilePictureUrl_starts_with?: Maybe<String>;
  profilePictureUrl_not_starts_with?: Maybe<String>;
  profilePictureUrl_ends_with?: Maybe<String>;
  profilePictureUrl_not_ends_with?: Maybe<String>;
  lmsEmpId?: Maybe<Int>;
  lmsEmpId_not?: Maybe<Int>;
  lmsEmpId_in?: Maybe<Int[] | Int>;
  lmsEmpId_not_in?: Maybe<Int[] | Int>;
  lmsEmpId_lt?: Maybe<Int>;
  lmsEmpId_lte?: Maybe<Int>;
  lmsEmpId_gt?: Maybe<Int>;
  lmsEmpId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  OR?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  NOT?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CounterStrikeScoreSetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CounterStrikeScoreSetWhereInput>;
  AND?: Maybe<
    | CounterStrikeScoreSetSubscriptionWhereInput[]
    | CounterStrikeScoreSetSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CounterStrikeScoreSetSubscriptionWhereInput[]
    | CounterStrikeScoreSetSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CounterStrikeScoreSetSubscriptionWhereInput[]
    | CounterStrikeScoreSetSubscriptionWhereInput
  >;
}

export interface TeamPlayerCreateInput {
  team: TeamCreateOneInput;
  player: SubTournamentPlayerCreateOneInput;
  isCaptain?: Maybe<Boolean>;
  updatedBy: UserAccountCreateOneInput;
}

export type CounterStrikeScoreSetActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamPlayerCreateOneInput {
  create?: Maybe<TeamPlayerCreateInput>;
  connect?: Maybe<TeamPlayerWhereUniqueInput>;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface CounterStrikeScoreSetCreateOneInput {
  create?: Maybe<CounterStrikeScoreSetCreateInput>;
  connect?: Maybe<CounterStrikeScoreSetWhereUniqueInput>;
}

export interface CounterStrikeScoreSetActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  set?: Maybe<CounterStrikeScoreSetWhereInput>;
  teamPlayer?: Maybe<TeamPlayerWhereInput>;
  kills?: Maybe<Int>;
  kills_not?: Maybe<Int>;
  kills_in?: Maybe<Int[] | Int>;
  kills_not_in?: Maybe<Int[] | Int>;
  kills_lt?: Maybe<Int>;
  kills_lte?: Maybe<Int>;
  kills_gt?: Maybe<Int>;
  kills_gte?: Maybe<Int>;
  deaths?: Maybe<Int>;
  deaths_not?: Maybe<Int>;
  deaths_in?: Maybe<Int[] | Int>;
  deaths_not_in?: Maybe<Int[] | Int>;
  deaths_lt?: Maybe<Int>;
  deaths_lte?: Maybe<Int>;
  deaths_gt?: Maybe<Int>;
  deaths_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | CounterStrikeScoreSetActivityWhereInput[]
    | CounterStrikeScoreSetActivityWhereInput
  >;
  OR?: Maybe<
    | CounterStrikeScoreSetActivityWhereInput[]
    | CounterStrikeScoreSetActivityWhereInput
  >;
  NOT?: Maybe<
    | CounterStrikeScoreSetActivityWhereInput[]
    | CounterStrikeScoreSetActivityWhereInput
  >;
}

export interface CounterStrikeScoreSetActivityCreateInput {
  set: CounterStrikeScoreSetCreateOneInput;
  teamPlayer: TeamPlayerCreateOneInput;
  kills: Int;
  deaths: Int;
  updatedBy: UserAccountCreateOneInput;
}

export interface SubTournamentPlayerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subTournament?: Maybe<SubTournamentWhereInput>;
  player?: Maybe<EmployeeWhereInput>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubTournamentPlayerWhereInput[] | SubTournamentPlayerWhereInput>;
  OR?: Maybe<SubTournamentPlayerWhereInput[] | SubTournamentPlayerWhereInput>;
  NOT?: Maybe<SubTournamentPlayerWhereInput[] | SubTournamentPlayerWhereInput>;
}

export type TeamPlayerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CarromBoardScoreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CarromBoardScoreWhereInput>;
  AND?: Maybe<
    | CarromBoardScoreSubscriptionWhereInput[]
    | CarromBoardScoreSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CarromBoardScoreSubscriptionWhereInput[]
    | CarromBoardScoreSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CarromBoardScoreSubscriptionWhereInput[]
    | CarromBoardScoreSubscriptionWhereInput
  >;
}

export interface CounterStrikeScoreSetUpdateManyMutationInput {
  set?: Maybe<Int>;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
}

export interface UserAccountTokenUpdateInput {
  user?: Maybe<UserAccountUpdateOneRequiredInput>;
  refreshToken?: Maybe<String>;
}

export interface CounterStrikeScoreSetUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  set?: Maybe<Int>;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface UserAccountTokenCreateInput {
  user: UserAccountCreateOneInput;
  refreshToken?: Maybe<String>;
}

export interface CounterStrikeScoreSetCreateInput {
  fixture: FixtureCreateOneInput;
  set: Int;
  homeTeamScore: Int;
  awayTeamScore: Int;
  updatedBy: UserAccountCreateOneInput;
}

export interface GameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GameWhereInput[] | GameWhereInput>;
  OR?: Maybe<GameWhereInput[] | GameWhereInput>;
  NOT?: Maybe<GameWhereInput[] | GameWhereInput>;
}

export interface CounterStrikeFScoreUpdateManyMutationInput {
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  setsCount?: Maybe<Int>;
}

export interface UserAccountUpdateInput {
  employeeId?: Maybe<EmployeeUpdateOneRequiredInput>;
  isActive?: Maybe<Boolean>;
  password?: Maybe<String>;
  userRole?: Maybe<UserRole>;
}

export type TournamentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type DotaScoreActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CounterStrikeFScoreUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  setsCount?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface DotaScoreActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  set?: Maybe<Int>;
  set_not?: Maybe<Int>;
  set_in?: Maybe<Int[] | Int>;
  set_not_in?: Maybe<Int[] | Int>;
  set_lt?: Maybe<Int>;
  set_lte?: Maybe<Int>;
  set_gt?: Maybe<Int>;
  set_gte?: Maybe<Int>;
  winnerTeam?: Maybe<TeamWhereInput>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DotaScoreActivityWhereInput[] | DotaScoreActivityWhereInput>;
  OR?: Maybe<DotaScoreActivityWhereInput[] | DotaScoreActivityWhereInput>;
  NOT?: Maybe<DotaScoreActivityWhereInput[] | DotaScoreActivityWhereInput>;
}

export interface CounterStrikeFScoreCreateInput {
  fixture: FixtureCreateOneInput;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  setsCount: Int;
  updatedBy: UserAccountCreateOneInput;
}

export interface TeamPlayerUpdateManyMutationInput {
  isCaptain?: Maybe<Boolean>;
}

export interface ChessScoreUpdateManyMutationInput {
  winningMethod?: Maybe<ChessWinningMethod>;
}

export interface TeamUpdateManyMutationInput {
  name?: Maybe<String>;
  logoImage?: Maybe<String>;
}

export interface ChessScoreUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  winnerTeam?: Maybe<TeamUpdateOneInput>;
  winningMethod?: Maybe<ChessWinningMethod>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface SubTournamentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  tournament?: Maybe<TournamentWhereInput>;
  category?: Maybe<CategoryWhereInput>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubTournamentWhereInput[] | SubTournamentWhereInput>;
  OR?: Maybe<SubTournamentWhereInput[] | SubTournamentWhereInput>;
  NOT?: Maybe<SubTournamentWhereInput[] | SubTournamentWhereInput>;
}

export type UserAccountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TableTennisScoreActivityUpdateManyMutationInput {
  set?: Maybe<Int>;
  homeTeamPoints?: Maybe<Int>;
  awayTeamPoints?: Maybe<Int>;
}

export interface ChessScoreCreateInput {
  fixture: FixtureCreateOneInput;
  winnerTeam?: Maybe<TeamCreateOneInput>;
  winningMethod?: Maybe<ChessWinningMethod>;
  updatedBy: UserAccountCreateOneInput;
}

export type FixtureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TableTennisScoreActivityCreateInput {
  fixture: FixtureCreateOneInput;
  set: Int;
  homeTeamPoints: Int;
  awayTeamPoints: Int;
  updatedBy: UserAccountCreateOneInput;
}

export interface CategoryUpdateInput {
  name?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface TableTennisScoreUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  setsCount?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface CarromBoardScoreActivityUpdateManyMutationInput {
  points?: Maybe<Int>;
  order?: Maybe<Int>;
}

export interface TableTennisScoreCreateInput {
  fixture: FixtureCreateOneInput;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  setsCount: Int;
  updatedBy: UserAccountCreateOneInput;
}

export type UserAccountTokenWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CarromBoardScoreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  homeTeamScore?: Maybe<Int>;
  homeTeamScore_not?: Maybe<Int>;
  homeTeamScore_in?: Maybe<Int[] | Int>;
  homeTeamScore_not_in?: Maybe<Int[] | Int>;
  homeTeamScore_lt?: Maybe<Int>;
  homeTeamScore_lte?: Maybe<Int>;
  homeTeamScore_gt?: Maybe<Int>;
  homeTeamScore_gte?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  awayTeamScore_not?: Maybe<Int>;
  awayTeamScore_in?: Maybe<Int[] | Int>;
  awayTeamScore_not_in?: Maybe<Int[] | Int>;
  awayTeamScore_lt?: Maybe<Int>;
  awayTeamScore_lte?: Maybe<Int>;
  awayTeamScore_gt?: Maybe<Int>;
  awayTeamScore_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CarromBoardScoreWhereInput[] | CarromBoardScoreWhereInput>;
  OR?: Maybe<CarromBoardScoreWhereInput[] | CarromBoardScoreWhereInput>;
  NOT?: Maybe<CarromBoardScoreWhereInput[] | CarromBoardScoreWhereInput>;
}

export interface TeamUpdateOneRequiredInput {
  create?: Maybe<TeamCreateInput>;
  update?: Maybe<TeamUpdateDataInput>;
  upsert?: Maybe<TeamUpsertNestedInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface SubTournamentPlayerUpdateInput {
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  player?: Maybe<EmployeeUpdateOneRequiredInput>;
  position?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface UserAccountTokenWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserAccountWhereInput>;
  refreshToken?: Maybe<String>;
  refreshToken_not?: Maybe<String>;
  refreshToken_in?: Maybe<String[] | String>;
  refreshToken_not_in?: Maybe<String[] | String>;
  refreshToken_lt?: Maybe<String>;
  refreshToken_lte?: Maybe<String>;
  refreshToken_gt?: Maybe<String>;
  refreshToken_gte?: Maybe<String>;
  refreshToken_contains?: Maybe<String>;
  refreshToken_not_contains?: Maybe<String>;
  refreshToken_starts_with?: Maybe<String>;
  refreshToken_not_starts_with?: Maybe<String>;
  refreshToken_ends_with?: Maybe<String>;
  refreshToken_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserAccountTokenWhereInput[] | UserAccountTokenWhereInput>;
  OR?: Maybe<UserAccountTokenWhereInput[] | UserAccountTokenWhereInput>;
  NOT?: Maybe<UserAccountTokenWhereInput[] | UserAccountTokenWhereInput>;
}

export type FootballScoreActivityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CarromBoardScoreActivityUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  team?: Maybe<TeamUpdateOneRequiredInput>;
  points?: Maybe<Int>;
  order?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface StatusUpdateInput {
  name?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface CarromBoardScoreActivityCreateInput {
  fixture: FixtureCreateOneInput;
  team: TeamCreateOneInput;
  points: Int;
  order: Int;
  updatedBy: UserAccountCreateOneInput;
}

export interface RoundUpdateManyMutationInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  sortOrder?: Maybe<Int>;
}

export interface CarromBoardScoreUpdateManyMutationInput {
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
}

export interface GameUpdateManyMutationInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
}

export interface FixtureUpsertNestedInput {
  update: FixtureUpdateDataInput;
  create: FixtureCreateInput;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamPlayerUpdateOneInput {
  create?: Maybe<TeamPlayerCreateInput>;
  update?: Maybe<TeamPlayerUpdateDataInput>;
  upsert?: Maybe<TeamPlayerUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamPlayerWhereUniqueInput>;
}

export interface FootballScoreActivityCreateInput {
  fixture: FixtureCreateOneInput;
  teamPlayer: TeamPlayerCreateOneInput;
  activityType: FootballActivityType;
  assistedBy?: Maybe<TeamPlayerCreateOneInput>;
  activityTime?: Maybe<String>;
  updatedBy: UserAccountCreateOneInput;
}

export interface CarromBoardScoreCreateInput {
  fixture: FixtureCreateOneInput;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  updatedBy: UserAccountCreateOneInput;
}

export interface FootballScoreUpdateManyMutationInput {
  homeTeamFTScore?: Maybe<Int>;
  awayTeamFTScore?: Maybe<Int>;
  homeTeamAetScore?: Maybe<Int>;
  awayTeamAetScore?: Maybe<Int>;
  homeTeamPenaltyScore?: Maybe<Int>;
  awayTeamPenaltyScore?: Maybe<Int>;
}

export interface FixtureCreateOneInput {
  create?: Maybe<FixtureCreateInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface FootballScoreCreateInput {
  fixture: FixtureCreateOneInput;
  homeTeamFTScore?: Maybe<Int>;
  awayTeamFTScore?: Maybe<Int>;
  homeTeamAetScore?: Maybe<Int>;
  awayTeamAetScore?: Maybe<Int>;
  homeTeamPenaltyScore?: Maybe<Int>;
  awayTeamPenaltyScore?: Maybe<Int>;
  updatedBy: UserAccountCreateOneInput;
}

export interface FixtureCreateInput {
  subTournament: SubTournamentCreateOneInput;
  status: StatusCreateOneInput;
  dateTime?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamCreateOneInput>;
  awayTeam?: Maybe<TeamCreateOneInput>;
  round: RoundCreateOneInput;
  homeTeamParentFixture?: Maybe<
    FixtureCreateOneWithoutHomeTeamParentFixtureInput
  >;
  awayTeamParentFixture?: Maybe<
    FixtureCreateOneWithoutAwayTeamParentFixtureInput
  >;
  images?: Maybe<FixtureCreateimagesInput>;
  updatedBy: UserAccountCreateOneInput;
}

export type StatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SubTournamentCreateOneInput {
  create?: Maybe<SubTournamentCreateInput>;
  connect?: Maybe<SubTournamentWhereUniqueInput>;
}

export interface EmployeeUpdateManyMutationInput {
  firstName?: Maybe<String>;
  middleName?: Maybe<String>;
  lastName?: Maybe<String>;
  profilePictureUrl?: Maybe<String>;
  lmsEmpId?: Maybe<Int>;
}

export interface SubTournamentCreateInput {
  tournament: TournamentCreateOneInput;
  category: CategoryCreateOneInput;
  updatedBy: UserAccountCreateOneInput;
}

export interface DotaScoreActivityUpdateManyMutationInput {
  set?: Maybe<Int>;
}

export interface TournamentCreateOneInput {
  create?: Maybe<TournamentCreateInput>;
  connect?: Maybe<TournamentWhereUniqueInput>;
}

export interface DotaScoreActivityUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  set?: Maybe<Int>;
  winnerTeam?: Maybe<TeamUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface TournamentCreateInput {
  game: GameCreateOneInput;
  season: String;
  startDate: DateTimeInput;
  finishDate?: Maybe<DateTimeInput>;
  updatedBy: UserAccountCreateOneInput;
}

export interface DotaScoreUpdateManyMutationInput {
  setsCount?: Maybe<Int>;
}

export interface GameCreateOneInput {
  create?: Maybe<GameCreateInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export type SubTournamentPlayerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GameCreateInput {
  name: String;
  shortName: String;
  updatedBy: UserAccountCreateOneInput;
}

export interface UserAccountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserAccountWhereInput>;
  AND?: Maybe<
    UserAccountSubscriptionWhereInput[] | UserAccountSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserAccountSubscriptionWhereInput[] | UserAccountSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserAccountSubscriptionWhereInput[] | UserAccountSubscriptionWhereInput
  >;
}

export interface UserAccountCreateOneInput {
  create?: Maybe<UserAccountCreateInput>;
  connect?: Maybe<UserAccountWhereUniqueInput>;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TeamWhereInput>;
  AND?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  OR?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  NOT?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
}

export interface UserAccountCreateInput {
  employeeId: EmployeeCreateOneInput;
  isActive: Boolean;
  password: String;
  userRole: UserRole;
}

export interface TableTennisScoreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TableTennisScoreWhereInput>;
  AND?: Maybe<
    | TableTennisScoreSubscriptionWhereInput[]
    | TableTennisScoreSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TableTennisScoreSubscriptionWhereInput[]
    | TableTennisScoreSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TableTennisScoreSubscriptionWhereInput[]
    | TableTennisScoreSubscriptionWhereInput
  >;
}

export interface EmployeeCreateOneInput {
  create?: Maybe<EmployeeCreateInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface StatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StatusWhereInput>;
  AND?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
  OR?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
  NOT?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
}

export interface EmployeeCreateInput {
  firstName: String;
  middleName?: Maybe<String>;
  lastName: String;
  profilePictureUrl?: Maybe<String>;
  lmsEmpId?: Maybe<Int>;
}

export interface RoundSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoundWhereInput>;
  AND?: Maybe<RoundSubscriptionWhereInput[] | RoundSubscriptionWhereInput>;
  OR?: Maybe<RoundSubscriptionWhereInput[] | RoundSubscriptionWhereInput>;
  NOT?: Maybe<RoundSubscriptionWhereInput[] | RoundSubscriptionWhereInput>;
}

export interface CategoryCreateOneInput {
  create?: Maybe<CategoryCreateInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface FootballScoreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FootballScoreWhereInput>;
  AND?: Maybe<
    FootballScoreSubscriptionWhereInput[] | FootballScoreSubscriptionWhereInput
  >;
  OR?: Maybe<
    FootballScoreSubscriptionWhereInput[] | FootballScoreSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FootballScoreSubscriptionWhereInput[] | FootballScoreSubscriptionWhereInput
  >;
}

export interface CategoryCreateInput {
  name: String;
  updatedBy: UserAccountCreateOneInput;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
  OR?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
  NOT?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
}

export interface StatusCreateOneInput {
  create?: Maybe<StatusCreateInput>;
  connect?: Maybe<StatusWhereUniqueInput>;
}

export interface CounterStrikeScoreSetWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  set?: Maybe<Int>;
  set_not?: Maybe<Int>;
  set_in?: Maybe<Int[] | Int>;
  set_not_in?: Maybe<Int[] | Int>;
  set_lt?: Maybe<Int>;
  set_lte?: Maybe<Int>;
  set_gt?: Maybe<Int>;
  set_gte?: Maybe<Int>;
  homeTeamScore?: Maybe<Int>;
  homeTeamScore_not?: Maybe<Int>;
  homeTeamScore_in?: Maybe<Int[] | Int>;
  homeTeamScore_not_in?: Maybe<Int[] | Int>;
  homeTeamScore_lt?: Maybe<Int>;
  homeTeamScore_lte?: Maybe<Int>;
  homeTeamScore_gt?: Maybe<Int>;
  homeTeamScore_gte?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  awayTeamScore_not?: Maybe<Int>;
  awayTeamScore_in?: Maybe<Int[] | Int>;
  awayTeamScore_not_in?: Maybe<Int[] | Int>;
  awayTeamScore_lt?: Maybe<Int>;
  awayTeamScore_lte?: Maybe<Int>;
  awayTeamScore_gt?: Maybe<Int>;
  awayTeamScore_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CounterStrikeScoreSetWhereInput[] | CounterStrikeScoreSetWhereInput
  >;
  OR?: Maybe<
    CounterStrikeScoreSetWhereInput[] | CounterStrikeScoreSetWhereInput
  >;
  NOT?: Maybe<
    CounterStrikeScoreSetWhereInput[] | CounterStrikeScoreSetWhereInput
  >;
}

export interface FixtureUpsertWithoutHomeTeamParentFixtureInput {
  update: FixtureUpdateWithoutHomeTeamParentFixtureDataInput;
  create: FixtureCreateWithoutHomeTeamParentFixtureInput;
}

export interface CounterStrikeFScoreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CounterStrikeFScoreWhereInput>;
  AND?: Maybe<
    | CounterStrikeFScoreSubscriptionWhereInput[]
    | CounterStrikeFScoreSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CounterStrikeFScoreSubscriptionWhereInput[]
    | CounterStrikeFScoreSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CounterStrikeFScoreSubscriptionWhereInput[]
    | CounterStrikeFScoreSubscriptionWhereInput
  >;
}

export interface TeamCreateOneInput {
  create?: Maybe<TeamCreateInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface CarromBoardScoreActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CarromBoardScoreActivityWhereInput>;
  AND?: Maybe<
    | CarromBoardScoreActivitySubscriptionWhereInput[]
    | CarromBoardScoreActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | CarromBoardScoreActivitySubscriptionWhereInput[]
    | CarromBoardScoreActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CarromBoardScoreActivitySubscriptionWhereInput[]
    | CarromBoardScoreActivitySubscriptionWhereInput
  >;
}

export interface TeamCreateInput {
  name: String;
  logoImage?: Maybe<String>;
  subTournament: SubTournamentCreateOneInput;
  updatedBy: UserAccountCreateOneInput;
}

export interface UserAccountWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  employeeId?: Maybe<EmployeeWhereInput>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  userRole?: Maybe<UserRole>;
  userRole_not?: Maybe<UserRole>;
  userRole_in?: Maybe<UserRole[] | UserRole>;
  userRole_not_in?: Maybe<UserRole[] | UserRole>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserAccountWhereInput[] | UserAccountWhereInput>;
  OR?: Maybe<UserAccountWhereInput[] | UserAccountWhereInput>;
  NOT?: Maybe<UserAccountWhereInput[] | UserAccountWhereInput>;
}

export interface RoundCreateOneInput {
  create?: Maybe<RoundCreateInput>;
  connect?: Maybe<RoundWhereUniqueInput>;
}

export type DotaScoreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RoundCreateInput {
  name: String;
  shortName: String;
  sortOrder: Int;
  updatedBy: UserAccountCreateOneInput;
}

export interface UserAccountUpdateManyMutationInput {
  isActive?: Maybe<Boolean>;
  password?: Maybe<String>;
  userRole?: Maybe<UserRole>;
}

export interface FixtureCreateOneWithoutHomeTeamParentFixtureInput {
  create?: Maybe<FixtureCreateWithoutHomeTeamParentFixtureInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface TournamentUpdateInput {
  game?: Maybe<GameUpdateOneRequiredInput>;
  season?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  finishDate?: Maybe<DateTimeInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface FixtureCreateWithoutHomeTeamParentFixtureInput {
  subTournament: SubTournamentCreateOneInput;
  status: StatusCreateOneInput;
  dateTime?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamCreateOneInput>;
  awayTeam?: Maybe<TeamCreateOneInput>;
  round: RoundCreateOneInput;
  awayTeamParentFixture?: Maybe<
    FixtureCreateOneWithoutAwayTeamParentFixtureInput
  >;
  images?: Maybe<FixtureCreateimagesInput>;
  updatedBy: UserAccountCreateOneInput;
}

export interface TeamPlayerUpdateInput {
  team?: Maybe<TeamUpdateOneRequiredInput>;
  player?: Maybe<SubTournamentPlayerUpdateOneRequiredInput>;
  isCaptain?: Maybe<Boolean>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface FixtureCreateOneWithoutAwayTeamParentFixtureInput {
  create?: Maybe<FixtureCreateWithoutAwayTeamParentFixtureInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface TeamUpdateInput {
  name?: Maybe<String>;
  logoImage?: Maybe<String>;
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface FixtureCreateWithoutAwayTeamParentFixtureInput {
  subTournament: SubTournamentCreateOneInput;
  status: StatusCreateOneInput;
  dateTime?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamCreateOneInput>;
  awayTeam?: Maybe<TeamCreateOneInput>;
  round: RoundCreateOneInput;
  homeTeamParentFixture?: Maybe<
    FixtureCreateOneWithoutHomeTeamParentFixtureInput
  >;
  images?: Maybe<FixtureCreateimagesInput>;
  updatedBy: UserAccountCreateOneInput;
}

export interface FixtureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subTournament?: Maybe<SubTournamentWhereInput>;
  status?: Maybe<StatusWhereInput>;
  dateTime?: Maybe<DateTimeInput>;
  dateTime_not?: Maybe<DateTimeInput>;
  dateTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTime_lt?: Maybe<DateTimeInput>;
  dateTime_lte?: Maybe<DateTimeInput>;
  dateTime_gt?: Maybe<DateTimeInput>;
  dateTime_gte?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamWhereInput>;
  awayTeam?: Maybe<TeamWhereInput>;
  round?: Maybe<RoundWhereInput>;
  homeTeamParentFixture?: Maybe<FixtureWhereInput>;
  awayTeamParentFixture?: Maybe<FixtureWhereInput>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FixtureWhereInput[] | FixtureWhereInput>;
  OR?: Maybe<FixtureWhereInput[] | FixtureWhereInput>;
  NOT?: Maybe<FixtureWhereInput[] | FixtureWhereInput>;
}

export interface FixtureCreateimagesInput {
  set?: Maybe<String[] | String>;
}

export type FootballScoreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CarromBoardScoreUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface SubTournamentPlayerUpdateManyMutationInput {
  position?: Maybe<String>;
}

export interface FixtureUpdateOneRequiredInput {
  create?: Maybe<FixtureCreateInput>;
  update?: Maybe<FixtureUpdateDataInput>;
  upsert?: Maybe<FixtureUpsertNestedInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface StatusUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface FixtureUpdateDataInput {
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  dateTime?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamUpdateOneInput>;
  awayTeam?: Maybe<TeamUpdateOneInput>;
  round?: Maybe<RoundUpdateOneRequiredInput>;
  homeTeamParentFixture?: Maybe<
    FixtureUpdateOneWithoutHomeTeamParentFixtureInput
  >;
  awayTeamParentFixture?: Maybe<
    FixtureUpdateOneWithoutAwayTeamParentFixtureInput
  >;
  images?: Maybe<FixtureUpdateimagesInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface RoundUpdateInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  sortOrder?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface SubTournamentUpdateOneRequiredInput {
  create?: Maybe<SubTournamentCreateInput>;
  update?: Maybe<SubTournamentUpdateDataInput>;
  upsert?: Maybe<SubTournamentUpsertNestedInput>;
  connect?: Maybe<SubTournamentWhereUniqueInput>;
}

export interface FootballScoreActivityUpdateManyMutationInput {
  activityType?: Maybe<FootballActivityType>;
  activityTime?: Maybe<String>;
}

export interface SubTournamentUpdateDataInput {
  tournament?: Maybe<TournamentUpdateOneRequiredInput>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export type RoundWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TournamentUpdateOneRequiredInput {
  create?: Maybe<TournamentCreateInput>;
  update?: Maybe<TournamentUpdateDataInput>;
  upsert?: Maybe<TournamentUpsertNestedInput>;
  connect?: Maybe<TournamentWhereUniqueInput>;
}

export interface FixtureUpdateManyMutationInput {
  dateTime?: Maybe<DateTimeInput>;
  images?: Maybe<FixtureUpdateimagesInput>;
}

export interface FixtureUpsertWithoutAwayTeamParentFixtureInput {
  update: FixtureUpdateWithoutAwayTeamParentFixtureDataInput;
  create: FixtureCreateWithoutAwayTeamParentFixtureInput;
}

export interface EmployeeUpdateInput {
  firstName?: Maybe<String>;
  middleName?: Maybe<String>;
  lastName?: Maybe<String>;
  profilePictureUrl?: Maybe<String>;
  lmsEmpId?: Maybe<Int>;
}

export interface GameUpdateOneRequiredInput {
  create?: Maybe<GameCreateInput>;
  update?: Maybe<GameUpdateDataInput>;
  upsert?: Maybe<GameUpsertNestedInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface DotaScoreActivityCreateInput {
  fixture: FixtureCreateOneInput;
  set: Int;
  winnerTeam: TeamCreateOneInput;
  updatedBy: UserAccountCreateOneInput;
}

export interface GameUpdateDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface UserAccountTokenSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserAccountTokenWhereInput>;
  AND?: Maybe<
    | UserAccountTokenSubscriptionWhereInput[]
    | UserAccountTokenSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserAccountTokenSubscriptionWhereInput[]
    | UserAccountTokenSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserAccountTokenSubscriptionWhereInput[]
    | UserAccountTokenSubscriptionWhereInput
  >;
}

export interface UserAccountUpdateOneRequiredInput {
  create?: Maybe<UserAccountCreateInput>;
  update?: Maybe<UserAccountUpdateDataInput>;
  upsert?: Maybe<UserAccountUpsertNestedInput>;
  connect?: Maybe<UserAccountWhereUniqueInput>;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserAccountUpdateDataInput {
  employeeId?: Maybe<EmployeeUpdateOneRequiredInput>;
  isActive?: Maybe<Boolean>;
  password?: Maybe<String>;
  userRole?: Maybe<UserRole>;
}

export interface ChessScoreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  winnerTeam?: Maybe<TeamWhereInput>;
  winningMethod?: Maybe<ChessWinningMethod>;
  winningMethod_not?: Maybe<ChessWinningMethod>;
  winningMethod_in?: Maybe<ChessWinningMethod[] | ChessWinningMethod>;
  winningMethod_not_in?: Maybe<ChessWinningMethod[] | ChessWinningMethod>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChessScoreWhereInput[] | ChessScoreWhereInput>;
  OR?: Maybe<ChessScoreWhereInput[] | ChessScoreWhereInput>;
  NOT?: Maybe<ChessScoreWhereInput[] | ChessScoreWhereInput>;
}

export interface EmployeeUpdateOneRequiredInput {
  create?: Maybe<EmployeeCreateInput>;
  update?: Maybe<EmployeeUpdateDataInput>;
  upsert?: Maybe<EmployeeUpsertNestedInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface EmployeeUpdateDataInput {
  firstName?: Maybe<String>;
  middleName?: Maybe<String>;
  lastName?: Maybe<String>;
  profilePictureUrl?: Maybe<String>;
  lmsEmpId?: Maybe<Int>;
}

export interface CounterStrikeScoreSetActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CounterStrikeScoreSetActivityWhereInput>;
  AND?: Maybe<
    | CounterStrikeScoreSetActivitySubscriptionWhereInput[]
    | CounterStrikeScoreSetActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | CounterStrikeScoreSetActivitySubscriptionWhereInput[]
    | CounterStrikeScoreSetActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CounterStrikeScoreSetActivitySubscriptionWhereInput[]
    | CounterStrikeScoreSetActivitySubscriptionWhereInput
  >;
}

export interface EmployeeUpsertNestedInput {
  update: EmployeeUpdateDataInput;
  create: EmployeeCreateInput;
}

export interface TeamPlayerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  team?: Maybe<TeamWhereInput>;
  player?: Maybe<SubTournamentPlayerWhereInput>;
  isCaptain?: Maybe<Boolean>;
  isCaptain_not?: Maybe<Boolean>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TeamPlayerWhereInput[] | TeamPlayerWhereInput>;
  OR?: Maybe<TeamPlayerWhereInput[] | TeamPlayerWhereInput>;
  NOT?: Maybe<TeamPlayerWhereInput[] | TeamPlayerWhereInput>;
}

export interface UserAccountUpsertNestedInput {
  update: UserAccountUpdateDataInput;
  create: UserAccountCreateInput;
}

export interface DotaScoreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  setsCount?: Maybe<Int>;
  setsCount_not?: Maybe<Int>;
  setsCount_in?: Maybe<Int[] | Int>;
  setsCount_not_in?: Maybe<Int[] | Int>;
  setsCount_lt?: Maybe<Int>;
  setsCount_lte?: Maybe<Int>;
  setsCount_gt?: Maybe<Int>;
  setsCount_gte?: Maybe<Int>;
  winnerTeam?: Maybe<TeamWhereInput>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DotaScoreWhereInput[] | DotaScoreWhereInput>;
  OR?: Maybe<DotaScoreWhereInput[] | DotaScoreWhereInput>;
  NOT?: Maybe<DotaScoreWhereInput[] | DotaScoreWhereInput>;
}

export interface GameUpsertNestedInput {
  update: GameUpdateDataInput;
  create: GameCreateInput;
}

export interface TournamentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  game?: Maybe<GameWhereInput>;
  season?: Maybe<String>;
  season_not?: Maybe<String>;
  season_in?: Maybe<String[] | String>;
  season_not_in?: Maybe<String[] | String>;
  season_lt?: Maybe<String>;
  season_lte?: Maybe<String>;
  season_gt?: Maybe<String>;
  season_gte?: Maybe<String>;
  season_contains?: Maybe<String>;
  season_not_contains?: Maybe<String>;
  season_starts_with?: Maybe<String>;
  season_not_starts_with?: Maybe<String>;
  season_ends_with?: Maybe<String>;
  season_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  finishDate?: Maybe<DateTimeInput>;
  finishDate_not?: Maybe<DateTimeInput>;
  finishDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  finishDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  finishDate_lt?: Maybe<DateTimeInput>;
  finishDate_lte?: Maybe<DateTimeInput>;
  finishDate_gt?: Maybe<DateTimeInput>;
  finishDate_gte?: Maybe<DateTimeInput>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TournamentWhereInput[] | TournamentWhereInput>;
  OR?: Maybe<TournamentWhereInput[] | TournamentWhereInput>;
  NOT?: Maybe<TournamentWhereInput[] | TournamentWhereInput>;
}

export interface TournamentUpsertNestedInput {
  update: TournamentUpdateDataInput;
  create: TournamentCreateInput;
}

export interface TableTennisScoreActivityUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  set?: Maybe<Int>;
  homeTeamPoints?: Maybe<Int>;
  awayTeamPoints?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface CategoryUpdateOneRequiredInput {
  create?: Maybe<CategoryCreateInput>;
  update?: Maybe<CategoryUpdateDataInput>;
  upsert?: Maybe<CategoryUpsertNestedInput>;
  connect?: Maybe<CategoryWhereUniqueInput>;
}

export interface FootballScoreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  homeTeamFTScore?: Maybe<Int>;
  homeTeamFTScore_not?: Maybe<Int>;
  homeTeamFTScore_in?: Maybe<Int[] | Int>;
  homeTeamFTScore_not_in?: Maybe<Int[] | Int>;
  homeTeamFTScore_lt?: Maybe<Int>;
  homeTeamFTScore_lte?: Maybe<Int>;
  homeTeamFTScore_gt?: Maybe<Int>;
  homeTeamFTScore_gte?: Maybe<Int>;
  awayTeamFTScore?: Maybe<Int>;
  awayTeamFTScore_not?: Maybe<Int>;
  awayTeamFTScore_in?: Maybe<Int[] | Int>;
  awayTeamFTScore_not_in?: Maybe<Int[] | Int>;
  awayTeamFTScore_lt?: Maybe<Int>;
  awayTeamFTScore_lte?: Maybe<Int>;
  awayTeamFTScore_gt?: Maybe<Int>;
  awayTeamFTScore_gte?: Maybe<Int>;
  homeTeamAetScore?: Maybe<Int>;
  homeTeamAetScore_not?: Maybe<Int>;
  homeTeamAetScore_in?: Maybe<Int[] | Int>;
  homeTeamAetScore_not_in?: Maybe<Int[] | Int>;
  homeTeamAetScore_lt?: Maybe<Int>;
  homeTeamAetScore_lte?: Maybe<Int>;
  homeTeamAetScore_gt?: Maybe<Int>;
  homeTeamAetScore_gte?: Maybe<Int>;
  awayTeamAetScore?: Maybe<Int>;
  awayTeamAetScore_not?: Maybe<Int>;
  awayTeamAetScore_in?: Maybe<Int[] | Int>;
  awayTeamAetScore_not_in?: Maybe<Int[] | Int>;
  awayTeamAetScore_lt?: Maybe<Int>;
  awayTeamAetScore_lte?: Maybe<Int>;
  awayTeamAetScore_gt?: Maybe<Int>;
  awayTeamAetScore_gte?: Maybe<Int>;
  homeTeamPenaltyScore?: Maybe<Int>;
  homeTeamPenaltyScore_not?: Maybe<Int>;
  homeTeamPenaltyScore_in?: Maybe<Int[] | Int>;
  homeTeamPenaltyScore_not_in?: Maybe<Int[] | Int>;
  homeTeamPenaltyScore_lt?: Maybe<Int>;
  homeTeamPenaltyScore_lte?: Maybe<Int>;
  homeTeamPenaltyScore_gt?: Maybe<Int>;
  homeTeamPenaltyScore_gte?: Maybe<Int>;
  awayTeamPenaltyScore?: Maybe<Int>;
  awayTeamPenaltyScore_not?: Maybe<Int>;
  awayTeamPenaltyScore_in?: Maybe<Int[] | Int>;
  awayTeamPenaltyScore_not_in?: Maybe<Int[] | Int>;
  awayTeamPenaltyScore_lt?: Maybe<Int>;
  awayTeamPenaltyScore_lte?: Maybe<Int>;
  awayTeamPenaltyScore_gt?: Maybe<Int>;
  awayTeamPenaltyScore_gte?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FootballScoreWhereInput[] | FootballScoreWhereInput>;
  OR?: Maybe<FootballScoreWhereInput[] | FootballScoreWhereInput>;
  NOT?: Maybe<FootballScoreWhereInput[] | FootballScoreWhereInput>;
}

export interface CategoryUpdateDataInput {
  name?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface FootballScoreActivityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  teamPlayer?: Maybe<TeamPlayerWhereInput>;
  activityType?: Maybe<FootballActivityType>;
  activityType_not?: Maybe<FootballActivityType>;
  activityType_in?: Maybe<FootballActivityType[] | FootballActivityType>;
  activityType_not_in?: Maybe<FootballActivityType[] | FootballActivityType>;
  assistedBy?: Maybe<TeamPlayerWhereInput>;
  activityTime?: Maybe<String>;
  activityTime_not?: Maybe<String>;
  activityTime_in?: Maybe<String[] | String>;
  activityTime_not_in?: Maybe<String[] | String>;
  activityTime_lt?: Maybe<String>;
  activityTime_lte?: Maybe<String>;
  activityTime_gt?: Maybe<String>;
  activityTime_gte?: Maybe<String>;
  activityTime_contains?: Maybe<String>;
  activityTime_not_contains?: Maybe<String>;
  activityTime_starts_with?: Maybe<String>;
  activityTime_not_starts_with?: Maybe<String>;
  activityTime_ends_with?: Maybe<String>;
  activityTime_not_ends_with?: Maybe<String>;
  updatedBy?: Maybe<UserAccountWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    FootballScoreActivityWhereInput[] | FootballScoreActivityWhereInput
  >;
  OR?: Maybe<
    FootballScoreActivityWhereInput[] | FootballScoreActivityWhereInput
  >;
  NOT?: Maybe<
    FootballScoreActivityWhereInput[] | FootballScoreActivityWhereInput
  >;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface FootballScoreActivityUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  teamPlayer?: Maybe<TeamPlayerUpdateOneRequiredInput>;
  activityType?: Maybe<FootballActivityType>;
  assistedBy?: Maybe<TeamPlayerUpdateOneInput>;
  activityTime?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface SubTournamentUpsertNestedInput {
  update: SubTournamentUpdateDataInput;
  create: SubTournamentCreateInput;
}

export interface FixtureUpdateInput {
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  dateTime?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamUpdateOneInput>;
  awayTeam?: Maybe<TeamUpdateOneInput>;
  round?: Maybe<RoundUpdateOneRequiredInput>;
  homeTeamParentFixture?: Maybe<
    FixtureUpdateOneWithoutHomeTeamParentFixtureInput
  >;
  awayTeamParentFixture?: Maybe<
    FixtureUpdateOneWithoutAwayTeamParentFixtureInput
  >;
  images?: Maybe<FixtureUpdateimagesInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface StatusUpdateOneRequiredInput {
  create?: Maybe<StatusCreateInput>;
  update?: Maybe<StatusUpdateDataInput>;
  upsert?: Maybe<StatusUpsertNestedInput>;
  connect?: Maybe<StatusWhereUniqueInput>;
}

export interface DotaScoreUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  setsCount?: Maybe<Int>;
  winnerTeam?: Maybe<TeamUpdateOneInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface StatusUpdateDataInput {
  name?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface SubTournamentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubTournamentWhereInput>;
  AND?: Maybe<
    SubTournamentSubscriptionWhereInput[] | SubTournamentSubscriptionWhereInput
  >;
  OR?: Maybe<
    SubTournamentSubscriptionWhereInput[] | SubTournamentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SubTournamentSubscriptionWhereInput[] | SubTournamentSubscriptionWhereInput
  >;
}

export interface StatusUpsertNestedInput {
  update: StatusUpdateDataInput;
  create: StatusCreateInput;
}

export type CounterStrikeScoreSetWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamUpdateOneInput {
  create?: Maybe<TeamCreateInput>;
  update?: Maybe<TeamUpdateDataInput>;
  upsert?: Maybe<TeamUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface UserAccountTokenUpdateManyMutationInput {
  refreshToken?: Maybe<String>;
}

export interface TeamUpdateDataInput {
  name?: Maybe<String>;
  logoImage?: Maybe<String>;
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamUpsertNestedInput {
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface SubTournamentUpdateInput {
  tournament?: Maybe<TournamentUpdateOneRequiredInput>;
  category?: Maybe<CategoryUpdateOneRequiredInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface RoundUpdateOneRequiredInput {
  create?: Maybe<RoundCreateInput>;
  update?: Maybe<RoundUpdateDataInput>;
  upsert?: Maybe<RoundUpsertNestedInput>;
  connect?: Maybe<RoundWhereUniqueInput>;
}

export interface FootballScoreUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredInput>;
  homeTeamFTScore?: Maybe<Int>;
  awayTeamFTScore?: Maybe<Int>;
  homeTeamAetScore?: Maybe<Int>;
  awayTeamAetScore?: Maybe<Int>;
  homeTeamPenaltyScore?: Maybe<Int>;
  awayTeamPenaltyScore?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface RoundUpdateDataInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  sortOrder?: Maybe<Int>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface TournamentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TournamentWhereInput>;
  AND?: Maybe<
    TournamentSubscriptionWhereInput[] | TournamentSubscriptionWhereInput
  >;
  OR?: Maybe<
    TournamentSubscriptionWhereInput[] | TournamentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TournamentSubscriptionWhereInput[] | TournamentSubscriptionWhereInput
  >;
}

export interface RoundUpsertNestedInput {
  update: RoundUpdateDataInput;
  create: RoundCreateInput;
}

export interface ChessScoreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChessScoreWhereInput>;
  AND?: Maybe<
    ChessScoreSubscriptionWhereInput[] | ChessScoreSubscriptionWhereInput
  >;
  OR?: Maybe<
    ChessScoreSubscriptionWhereInput[] | ChessScoreSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ChessScoreSubscriptionWhereInput[] | ChessScoreSubscriptionWhereInput
  >;
}

export interface FixtureUpdateWithoutAwayTeamParentFixtureDataInput {
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  dateTime?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamUpdateOneInput>;
  awayTeam?: Maybe<TeamUpdateOneInput>;
  round?: Maybe<RoundUpdateOneRequiredInput>;
  homeTeamParentFixture?: Maybe<
    FixtureUpdateOneWithoutHomeTeamParentFixtureInput
  >;
  images?: Maybe<FixtureUpdateimagesInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface FixtureUpdateOneWithoutAwayTeamParentFixtureInput {
  create?: Maybe<FixtureCreateWithoutAwayTeamParentFixtureInput>;
  update?: Maybe<FixtureUpdateWithoutAwayTeamParentFixtureDataInput>;
  upsert?: Maybe<FixtureUpsertWithoutAwayTeamParentFixtureInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface FixtureUpdateWithoutHomeTeamParentFixtureDataInput {
  subTournament?: Maybe<SubTournamentUpdateOneRequiredInput>;
  status?: Maybe<StatusUpdateOneRequiredInput>;
  dateTime?: Maybe<DateTimeInput>;
  homeTeam?: Maybe<TeamUpdateOneInput>;
  awayTeam?: Maybe<TeamUpdateOneInput>;
  round?: Maybe<RoundUpdateOneRequiredInput>;
  awayTeamParentFixture?: Maybe<
    FixtureUpdateOneWithoutAwayTeamParentFixtureInput
  >;
  images?: Maybe<FixtureUpdateimagesInput>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface FixtureUpdateOneWithoutHomeTeamParentFixtureInput {
  create?: Maybe<FixtureCreateWithoutHomeTeamParentFixtureInput>;
  update?: Maybe<FixtureUpdateWithoutHomeTeamParentFixtureDataInput>;
  upsert?: Maybe<FixtureUpsertWithoutHomeTeamParentFixtureInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface TournamentUpdateManyMutationInput {
  season?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  finishDate?: Maybe<DateTimeInput>;
}

export interface FootballScoreActivitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FootballScoreActivityWhereInput>;
  AND?: Maybe<
    | FootballScoreActivitySubscriptionWhereInput[]
    | FootballScoreActivitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | FootballScoreActivitySubscriptionWhereInput[]
    | FootballScoreActivitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | FootballScoreActivitySubscriptionWhereInput[]
    | FootballScoreActivitySubscriptionWhereInput
  >;
}

export type SubTournamentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GameUpdateInput {
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  updatedBy?: Maybe<UserAccountUpdateOneRequiredInput>;
}

export interface TableTennisScoreUpdateManyMutationInput {
  homeTeamScore?: Maybe<Int>;
  awayTeamScore?: Maybe<Int>;
  setsCount?: Maybe<Int>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserAccountTokenPreviousValues {
  id: ID_Output;
  refreshToken?: String;
}

export interface UserAccountTokenPreviousValuesPromise
  extends Promise<UserAccountTokenPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  refreshToken: () => Promise<String>;
}

export interface UserAccountTokenPreviousValuesSubscription
  extends Promise<AsyncIterator<UserAccountTokenPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
}

export interface DotaScore {
  id: ID_Output;
  setsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DotaScorePromise extends Promise<DotaScore>, Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  setsCount: () => Promise<Int>;
  winnerTeam: <T = TeamPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DotaScoreSubscription
  extends Promise<AsyncIterator<DotaScore>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  setsCount: () => Promise<AsyncIterator<Int>>;
  winnerTeam: <T = TeamSubscription>() => T;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DotaScoreNullablePromise
  extends Promise<DotaScore | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  setsCount: () => Promise<Int>;
  winnerTeam: <T = TeamPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCounterStrikeScoreSetActivity {
  count: Int;
}

export interface AggregateCounterStrikeScoreSetActivityPromise
  extends Promise<AggregateCounterStrikeScoreSetActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCounterStrikeScoreSetActivitySubscription
  extends Promise<AsyncIterator<AggregateCounterStrikeScoreSetActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CarromBoardScoreEdge {
  node: CarromBoardScore;
  cursor: String;
}

export interface CarromBoardScoreEdgePromise
  extends Promise<CarromBoardScoreEdge>,
    Fragmentable {
  node: <T = CarromBoardScorePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CarromBoardScoreEdgeSubscription
  extends Promise<AsyncIterator<CarromBoardScoreEdge>>,
    Fragmentable {
  node: <T = CarromBoardScoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CounterStrikeScoreSetActivityEdge {
  node: CounterStrikeScoreSetActivity;
  cursor: String;
}

export interface CounterStrikeScoreSetActivityEdgePromise
  extends Promise<CounterStrikeScoreSetActivityEdge>,
    Fragmentable {
  node: <T = CounterStrikeScoreSetActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CounterStrikeScoreSetActivityEdgeSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetActivityEdge>>,
    Fragmentable {
  node: <T = CounterStrikeScoreSetActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserAccountToken {
  count: Int;
}

export interface AggregateUserAccountTokenPromise
  extends Promise<AggregateUserAccountToken>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserAccountTokenSubscription
  extends Promise<AsyncIterator<AggregateUserAccountToken>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CounterStrikeScoreSetActivityConnection {
  pageInfo: PageInfo;
  edges: CounterStrikeScoreSetActivityEdge[];
}

export interface CounterStrikeScoreSetActivityConnectionPromise
  extends Promise<CounterStrikeScoreSetActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CounterStrikeScoreSetActivityEdge>>() => T;
  aggregate: <T = AggregateCounterStrikeScoreSetActivityPromise>() => T;
}

export interface CounterStrikeScoreSetActivityConnectionSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CounterStrikeScoreSetActivityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCounterStrikeScoreSetActivitySubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CarromBoardScore {
  id: ID_Output;
  homeTeamScore?: Int;
  awayTeamScore?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CarromBoardScorePromise
  extends Promise<CarromBoardScore>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CarromBoardScoreSubscription
  extends Promise<AsyncIterator<CarromBoardScore>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CarromBoardScoreNullablePromise
  extends Promise<CarromBoardScore | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAccountTokenConnection {
  pageInfo: PageInfo;
  edges: UserAccountTokenEdge[];
}

export interface UserAccountTokenConnectionPromise
  extends Promise<UserAccountTokenConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserAccountTokenEdge>>() => T;
  aggregate: <T = AggregateUserAccountTokenPromise>() => T;
}

export interface UserAccountTokenConnectionSubscription
  extends Promise<AsyncIterator<UserAccountTokenConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserAccountTokenEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserAccountTokenSubscription>() => T;
}

export interface CarromBoardScoreSubscriptionPayload {
  mutation: MutationType;
  node: CarromBoardScore;
  updatedFields: String[];
  previousValues: CarromBoardScorePreviousValues;
}

export interface CarromBoardScoreSubscriptionPayloadPromise
  extends Promise<CarromBoardScoreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CarromBoardScorePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CarromBoardScorePreviousValuesPromise>() => T;
}

export interface CarromBoardScoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CarromBoardScoreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CarromBoardScoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CarromBoardScorePreviousValuesSubscription>() => T;
}

export interface UserAccountToken {
  id: ID_Output;
  refreshToken?: String;
}

export interface UserAccountTokenPromise
  extends Promise<UserAccountToken>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserAccountPromise>() => T;
  refreshToken: () => Promise<String>;
}

export interface UserAccountTokenSubscription
  extends Promise<AsyncIterator<UserAccountToken>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserAccountSubscription>() => T;
  refreshToken: () => Promise<AsyncIterator<String>>;
}

export interface UserAccountTokenNullablePromise
  extends Promise<UserAccountToken | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserAccountPromise>() => T;
  refreshToken: () => Promise<String>;
}

export interface CarromBoardScorePreviousValues {
  id: ID_Output;
  homeTeamScore?: Int;
  awayTeamScore?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CarromBoardScorePreviousValuesPromise
  extends Promise<CarromBoardScorePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CarromBoardScorePreviousValuesSubscription
  extends Promise<AsyncIterator<CarromBoardScorePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAccountEdge {
  node: UserAccount;
  cursor: String;
}

export interface UserAccountEdgePromise
  extends Promise<UserAccountEdge>,
    Fragmentable {
  node: <T = UserAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserAccountEdgeSubscription
  extends Promise<AsyncIterator<UserAccountEdge>>,
    Fragmentable {
  node: <T = UserAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubTournamentPlayer {
  id: ID_Output;
  position?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubTournamentPlayerPromise
  extends Promise<SubTournamentPlayer>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subTournament: <T = SubTournamentPromise>() => T;
  player: <T = EmployeePromise>() => T;
  position: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubTournamentPlayerSubscription
  extends Promise<AsyncIterator<SubTournamentPlayer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subTournament: <T = SubTournamentSubscription>() => T;
  player: <T = EmployeeSubscription>() => T;
  position: () => Promise<AsyncIterator<String>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubTournamentPlayerNullablePromise
  extends Promise<SubTournamentPlayer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subTournament: <T = SubTournamentPromise>() => T;
  player: <T = EmployeePromise>() => T;
  position: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubTournament {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubTournamentPromise
  extends Promise<SubTournament>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tournament: <T = TournamentPromise>() => T;
  category: <T = CategoryPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubTournamentSubscription
  extends Promise<AsyncIterator<SubTournament>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tournament: <T = TournamentSubscription>() => T;
  category: <T = CategorySubscription>() => T;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubTournamentNullablePromise
  extends Promise<SubTournament | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tournament: <T = TournamentPromise>() => T;
  category: <T = CategoryPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CarromBoardScoreActivitySubscriptionPayload {
  mutation: MutationType;
  node: CarromBoardScoreActivity;
  updatedFields: String[];
  previousValues: CarromBoardScoreActivityPreviousValues;
}

export interface CarromBoardScoreActivitySubscriptionPayloadPromise
  extends Promise<CarromBoardScoreActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CarromBoardScoreActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CarromBoardScoreActivityPreviousValuesPromise>() => T;
}

export interface CarromBoardScoreActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CarromBoardScoreActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CarromBoardScoreActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = CarromBoardScoreActivityPreviousValuesSubscription
  >() => T;
}

export interface TournamentEdge {
  node: Tournament;
  cursor: String;
}

export interface TournamentEdgePromise
  extends Promise<TournamentEdge>,
    Fragmentable {
  node: <T = TournamentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TournamentEdgeSubscription
  extends Promise<AsyncIterator<TournamentEdge>>,
    Fragmentable {
  node: <T = TournamentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CarromBoardScoreActivityPreviousValues {
  id: ID_Output;
  points: Int;
  order: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CarromBoardScoreActivityPreviousValuesPromise
  extends Promise<CarromBoardScoreActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  points: () => Promise<Int>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CarromBoardScoreActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<CarromBoardScoreActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  points: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Tournament {
  id: ID_Output;
  season: String;
  startDate: DateTimeOutput;
  finishDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TournamentPromise extends Promise<Tournament>, Fragmentable {
  id: () => Promise<ID_Output>;
  game: <T = GamePromise>() => T;
  season: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  finishDate: () => Promise<DateTimeOutput>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TournamentSubscription
  extends Promise<AsyncIterator<Tournament>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  game: <T = GameSubscription>() => T;
  season: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  finishDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TournamentNullablePromise
  extends Promise<Tournament | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  game: <T = GamePromise>() => T;
  season: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  finishDate: () => Promise<DateTimeOutput>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamPlayer {
  id: ID_Output;
  isCaptain: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TeamPlayerPromise extends Promise<TeamPlayer>, Fragmentable {
  id: () => Promise<ID_Output>;
  team: <T = TeamPromise>() => T;
  player: <T = SubTournamentPlayerPromise>() => T;
  isCaptain: () => Promise<Boolean>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamPlayerSubscription
  extends Promise<AsyncIterator<TeamPlayer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  team: <T = TeamSubscription>() => T;
  player: <T = SubTournamentPlayerSubscription>() => T;
  isCaptain: () => Promise<AsyncIterator<Boolean>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TeamPlayerNullablePromise
  extends Promise<TeamPlayer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  team: <T = TeamPromise>() => T;
  player: <T = SubTournamentPlayerPromise>() => T;
  isCaptain: () => Promise<Boolean>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamPlayerEdge {
  node: TeamPlayer;
  cursor: String;
}

export interface TeamPlayerEdgePromise
  extends Promise<TeamPlayerEdge>,
    Fragmentable {
  node: <T = TeamPlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamPlayerEdgeSubscription
  extends Promise<AsyncIterator<TeamPlayerEdge>>,
    Fragmentable {
  node: <T = TeamPlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface Game {
  id: ID_Output;
  name: String;
  shortName: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GameNullablePromise
  extends Promise<Game | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CounterStrikeScoreSetActivity {
  id: ID_Output;
  kills: Int;
  deaths: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CounterStrikeScoreSetActivityPromise
  extends Promise<CounterStrikeScoreSetActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  set: <T = CounterStrikeScoreSetPromise>() => T;
  teamPlayer: <T = TeamPlayerPromise>() => T;
  kills: () => Promise<Int>;
  deaths: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CounterStrikeScoreSetActivitySubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  set: <T = CounterStrikeScoreSetSubscription>() => T;
  teamPlayer: <T = TeamPlayerSubscription>() => T;
  kills: () => Promise<AsyncIterator<Int>>;
  deaths: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CounterStrikeScoreSetActivityNullablePromise
  extends Promise<CounterStrikeScoreSetActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  set: <T = CounterStrikeScoreSetPromise>() => T;
  teamPlayer: <T = TeamPlayerPromise>() => T;
  kills: () => Promise<Int>;
  deaths: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScoreActivityEdge {
  node: TableTennisScoreActivity;
  cursor: String;
}

export interface TableTennisScoreActivityEdgePromise
  extends Promise<TableTennisScoreActivityEdge>,
    Fragmentable {
  node: <T = TableTennisScoreActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TableTennisScoreActivityEdgeSubscription
  extends Promise<AsyncIterator<TableTennisScoreActivityEdge>>,
    Fragmentable {
  node: <T = TableTennisScoreActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChessScoreSubscriptionPayload {
  mutation: MutationType;
  node: ChessScore;
  updatedFields: String[];
  previousValues: ChessScorePreviousValues;
}

export interface ChessScoreSubscriptionPayloadPromise
  extends Promise<ChessScoreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChessScorePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChessScorePreviousValuesPromise>() => T;
}

export interface ChessScoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChessScoreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChessScoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChessScorePreviousValuesSubscription>() => T;
}

export interface UserAccount {
  id: ID_Output;
  isActive: Boolean;
  password: String;
  userRole: UserRole;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAccountPromise extends Promise<UserAccount>, Fragmentable {
  id: () => Promise<ID_Output>;
  employeeId: <T = EmployeePromise>() => T;
  isActive: () => Promise<Boolean>;
  password: () => Promise<String>;
  userRole: () => Promise<UserRole>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAccountSubscription
  extends Promise<AsyncIterator<UserAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  employeeId: <T = EmployeeSubscription>() => T;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  userRole: () => Promise<AsyncIterator<UserRole>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAccountNullablePromise
  extends Promise<UserAccount | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  employeeId: <T = EmployeePromise>() => T;
  isActive: () => Promise<Boolean>;
  password: () => Promise<String>;
  userRole: () => Promise<UserRole>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChessScorePreviousValues {
  id: ID_Output;
  winningMethod?: ChessWinningMethod;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ChessScorePreviousValuesPromise
  extends Promise<ChessScorePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  winningMethod: () => Promise<ChessWinningMethod>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChessScorePreviousValuesSubscription
  extends Promise<AsyncIterator<ChessScorePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  winningMethod: () => Promise<AsyncIterator<ChessWinningMethod>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTableTennisScore {
  count: Int;
}

export interface AggregateTableTennisScorePromise
  extends Promise<AggregateTableTennisScore>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTableTennisScoreSubscription
  extends Promise<AsyncIterator<AggregateTableTennisScore>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCounterStrikeScoreSet {
  count: Int;
}

export interface AggregateCounterStrikeScoreSetPromise
  extends Promise<AggregateCounterStrikeScoreSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCounterStrikeScoreSetSubscription
  extends Promise<AsyncIterator<AggregateCounterStrikeScoreSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TableTennisScoreConnection {
  pageInfo: PageInfo;
  edges: TableTennisScoreEdge[];
}

export interface TableTennisScoreConnectionPromise
  extends Promise<TableTennisScoreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TableTennisScoreEdge>>() => T;
  aggregate: <T = AggregateTableTennisScorePromise>() => T;
}

export interface TableTennisScoreConnectionSubscription
  extends Promise<AsyncIterator<TableTennisScoreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TableTennisScoreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTableTennisScoreSubscription>() => T;
}

export interface CounterStrikeFScoreSubscriptionPayload {
  mutation: MutationType;
  node: CounterStrikeFScore;
  updatedFields: String[];
  previousValues: CounterStrikeFScorePreviousValues;
}

export interface CounterStrikeFScoreSubscriptionPayloadPromise
  extends Promise<CounterStrikeFScoreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CounterStrikeFScorePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CounterStrikeFScorePreviousValuesPromise>() => T;
}

export interface CounterStrikeFScoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CounterStrikeFScoreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CounterStrikeFScoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CounterStrikeFScorePreviousValuesSubscription>() => T;
}

export interface TableTennisScore {
  id: ID_Output;
  homeTeamScore?: Int;
  awayTeamScore?: Int;
  setsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TableTennisScorePromise
  extends Promise<TableTennisScore>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  setsCount: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScoreSubscription
  extends Promise<AsyncIterator<TableTennisScore>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  setsCount: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TableTennisScoreNullablePromise
  extends Promise<TableTennisScore | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  setsCount: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CounterStrikeFScorePreviousValues {
  id: ID_Output;
  homeTeamScore?: Int;
  awayTeamScore?: Int;
  setsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CounterStrikeFScorePreviousValuesPromise
  extends Promise<CounterStrikeFScorePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  setsCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CounterStrikeFScorePreviousValuesSubscription
  extends Promise<AsyncIterator<CounterStrikeFScorePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  setsCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubTournamentPlayerEdge {
  node: SubTournamentPlayer;
  cursor: String;
}

export interface SubTournamentPlayerEdgePromise
  extends Promise<SubTournamentPlayerEdge>,
    Fragmentable {
  node: <T = SubTournamentPlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubTournamentPlayerEdgeSubscription
  extends Promise<AsyncIterator<SubTournamentPlayerEdge>>,
    Fragmentable {
  node: <T = SubTournamentPlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubTournamentPlayer {
  count: Int;
}

export interface AggregateSubTournamentPlayerPromise
  extends Promise<AggregateSubTournamentPlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubTournamentPlayerSubscription
  extends Promise<AsyncIterator<AggregateSubTournamentPlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CarromBoardScoreActivity {
  id: ID_Output;
  points: Int;
  order: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CarromBoardScoreActivityPromise
  extends Promise<CarromBoardScoreActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  team: <T = TeamPromise>() => T;
  points: () => Promise<Int>;
  order: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CarromBoardScoreActivitySubscription
  extends Promise<AsyncIterator<CarromBoardScoreActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  points: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CarromBoardScoreActivityNullablePromise
  extends Promise<CarromBoardScoreActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  team: <T = TeamPromise>() => T;
  points: () => Promise<Int>;
  order: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubTournamentPlayerConnection {
  pageInfo: PageInfo;
  edges: SubTournamentPlayerEdge[];
}

export interface SubTournamentPlayerConnectionPromise
  extends Promise<SubTournamentPlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubTournamentPlayerEdge>>() => T;
  aggregate: <T = AggregateSubTournamentPlayerPromise>() => T;
}

export interface SubTournamentPlayerConnectionSubscription
  extends Promise<AsyncIterator<SubTournamentPlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SubTournamentPlayerEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSubTournamentPlayerSubscription>() => T;
}

export interface CounterStrikeScoreSetEdge {
  node: CounterStrikeScoreSet;
  cursor: String;
}

export interface CounterStrikeScoreSetEdgePromise
  extends Promise<CounterStrikeScoreSetEdge>,
    Fragmentable {
  node: <T = CounterStrikeScoreSetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CounterStrikeScoreSetEdgeSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetEdge>>,
    Fragmentable {
  node: <T = CounterStrikeScoreSetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubTournament {
  count: Int;
}

export interface AggregateSubTournamentPromise
  extends Promise<AggregateSubTournament>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubTournamentSubscription
  extends Promise<AsyncIterator<AggregateSubTournament>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubTournamentConnection {
  pageInfo: PageInfo;
  edges: SubTournamentEdge[];
}

export interface SubTournamentConnectionPromise
  extends Promise<SubTournamentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubTournamentEdge>>() => T;
  aggregate: <T = AggregateSubTournamentPromise>() => T;
}

export interface SubTournamentConnectionSubscription
  extends Promise<AsyncIterator<SubTournamentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubTournamentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubTournamentSubscription>() => T;
}

export interface CounterStrikeScoreSetSubscriptionPayload {
  mutation: MutationType;
  node: CounterStrikeScoreSet;
  updatedFields: String[];
  previousValues: CounterStrikeScoreSetPreviousValues;
}

export interface CounterStrikeScoreSetSubscriptionPayloadPromise
  extends Promise<CounterStrikeScoreSetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CounterStrikeScoreSetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CounterStrikeScoreSetPreviousValuesPromise>() => T;
}

export interface CounterStrikeScoreSetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CounterStrikeScoreSetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CounterStrikeScoreSetPreviousValuesSubscription>() => T;
}

export interface AggregateStatus {
  count: Int;
}

export interface AggregateStatusPromise
  extends Promise<AggregateStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStatusSubscription
  extends Promise<AsyncIterator<AggregateStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CounterStrikeScoreSetPreviousValues {
  id: ID_Output;
  set: Int;
  homeTeamScore: Int;
  awayTeamScore: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CounterStrikeScoreSetPreviousValuesPromise
  extends Promise<CounterStrikeScoreSetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  set: () => Promise<Int>;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CounterStrikeScoreSetPreviousValuesSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  set: () => Promise<AsyncIterator<Int>>;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StatusConnection {
  pageInfo: PageInfo;
  edges: StatusEdge[];
}

export interface StatusConnectionPromise
  extends Promise<StatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StatusEdge>>() => T;
  aggregate: <T = AggregateStatusPromise>() => T;
}

export interface StatusConnectionSubscription
  extends Promise<AsyncIterator<StatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStatusSubscription>() => T;
}

export interface CounterStrikeScoreSetConnection {
  pageInfo: PageInfo;
  edges: CounterStrikeScoreSetEdge[];
}

export interface CounterStrikeScoreSetConnectionPromise
  extends Promise<CounterStrikeScoreSetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CounterStrikeScoreSetEdge>>() => T;
  aggregate: <T = AggregateCounterStrikeScoreSetPromise>() => T;
}

export interface CounterStrikeScoreSetConnectionSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CounterStrikeScoreSetEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCounterStrikeScoreSetSubscription>() => T;
}

export interface AggregateRound {
  count: Int;
}

export interface AggregateRoundPromise
  extends Promise<AggregateRound>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoundSubscription
  extends Promise<AsyncIterator<AggregateRound>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CounterStrikeScoreSetActivitySubscriptionPayload {
  mutation: MutationType;
  node: CounterStrikeScoreSetActivity;
  updatedFields: String[];
  previousValues: CounterStrikeScoreSetActivityPreviousValues;
}

export interface CounterStrikeScoreSetActivitySubscriptionPayloadPromise
  extends Promise<CounterStrikeScoreSetActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CounterStrikeScoreSetActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = CounterStrikeScoreSetActivityPreviousValuesPromise
  >() => T;
}

export interface CounterStrikeScoreSetActivitySubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<CounterStrikeScoreSetActivitySubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CounterStrikeScoreSetActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = CounterStrikeScoreSetActivityPreviousValuesSubscription
  >() => T;
}

export interface RoundConnection {
  pageInfo: PageInfo;
  edges: RoundEdge[];
}

export interface RoundConnectionPromise
  extends Promise<RoundConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoundEdge>>() => T;
  aggregate: <T = AggregateRoundPromise>() => T;
}

export interface RoundConnectionSubscription
  extends Promise<AsyncIterator<RoundConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoundEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoundSubscription>() => T;
}

export interface CounterStrikeScoreSetActivityPreviousValues {
  id: ID_Output;
  kills: Int;
  deaths: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CounterStrikeScoreSetActivityPreviousValuesPromise
  extends Promise<CounterStrikeScoreSetActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kills: () => Promise<Int>;
  deaths: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CounterStrikeScoreSetActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSetActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kills: () => Promise<AsyncIterator<Int>>;
  deaths: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CounterStrikeScoreSet {
  id: ID_Output;
  set: Int;
  homeTeamScore: Int;
  awayTeamScore: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CounterStrikeScoreSetPromise
  extends Promise<CounterStrikeScoreSet>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  set: () => Promise<Int>;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CounterStrikeScoreSetSubscription
  extends Promise<AsyncIterator<CounterStrikeScoreSet>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  set: () => Promise<AsyncIterator<Int>>;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CounterStrikeScoreSetNullablePromise
  extends Promise<CounterStrikeScoreSet | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  set: () => Promise<Int>;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface DotaScoreSubscriptionPayload {
  mutation: MutationType;
  node: DotaScore;
  updatedFields: String[];
  previousValues: DotaScorePreviousValues;
}

export interface DotaScoreSubscriptionPayloadPromise
  extends Promise<DotaScoreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DotaScorePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DotaScorePreviousValuesPromise>() => T;
}

export interface DotaScoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DotaScoreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DotaScoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DotaScorePreviousValuesSubscription>() => T;
}

export interface AggregateFootballScoreActivity {
  count: Int;
}

export interface AggregateFootballScoreActivityPromise
  extends Promise<AggregateFootballScoreActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFootballScoreActivitySubscription
  extends Promise<AsyncIterator<AggregateFootballScoreActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DotaScorePreviousValues {
  id: ID_Output;
  setsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DotaScorePreviousValuesPromise
  extends Promise<DotaScorePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  setsCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DotaScorePreviousValuesSubscription
  extends Promise<AsyncIterator<DotaScorePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  setsCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FootballScoreActivityConnection {
  pageInfo: PageInfo;
  edges: FootballScoreActivityEdge[];
}

export interface FootballScoreActivityConnectionPromise
  extends Promise<FootballScoreActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FootballScoreActivityEdge>>() => T;
  aggregate: <T = AggregateFootballScoreActivityPromise>() => T;
}

export interface FootballScoreActivityConnectionSubscription
  extends Promise<AsyncIterator<FootballScoreActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<FootballScoreActivityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateFootballScoreActivitySubscription>() => T;
}

export interface AggregateCounterStrikeFScore {
  count: Int;
}

export interface AggregateCounterStrikeFScorePromise
  extends Promise<AggregateCounterStrikeFScore>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCounterStrikeFScoreSubscription
  extends Promise<AsyncIterator<AggregateCounterStrikeFScore>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Round {
  id: ID_Output;
  name: String;
  shortName: String;
  sortOrder: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RoundPromise extends Promise<Round>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  sortOrder: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoundSubscription
  extends Promise<AsyncIterator<Round>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  sortOrder: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoundNullablePromise
  extends Promise<Round | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  sortOrder: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DotaScoreActivitySubscriptionPayload {
  mutation: MutationType;
  node: DotaScoreActivity;
  updatedFields: String[];
  previousValues: DotaScoreActivityPreviousValues;
}

export interface DotaScoreActivitySubscriptionPayloadPromise
  extends Promise<DotaScoreActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DotaScoreActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DotaScoreActivityPreviousValuesPromise>() => T;
}

export interface DotaScoreActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DotaScoreActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DotaScoreActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DotaScoreActivityPreviousValuesSubscription>() => T;
}

export interface AggregateFootballScore {
  count: Int;
}

export interface AggregateFootballScorePromise
  extends Promise<AggregateFootballScore>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFootballScoreSubscription
  extends Promise<AsyncIterator<AggregateFootballScore>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DotaScoreActivityPreviousValues {
  id: ID_Output;
  set: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DotaScoreActivityPreviousValuesPromise
  extends Promise<DotaScoreActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  set: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DotaScoreActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<DotaScoreActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  set: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FootballScoreConnection {
  pageInfo: PageInfo;
  edges: FootballScoreEdge[];
}

export interface FootballScoreConnectionPromise
  extends Promise<FootballScoreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FootballScoreEdge>>() => T;
  aggregate: <T = AggregateFootballScorePromise>() => T;
}

export interface FootballScoreConnectionSubscription
  extends Promise<AsyncIterator<FootballScoreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FootballScoreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFootballScoreSubscription>() => T;
}

export interface CounterStrikeFScoreEdge {
  node: CounterStrikeFScore;
  cursor: String;
}

export interface CounterStrikeFScoreEdgePromise
  extends Promise<CounterStrikeFScoreEdge>,
    Fragmentable {
  node: <T = CounterStrikeFScorePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CounterStrikeFScoreEdgeSubscription
  extends Promise<AsyncIterator<CounterStrikeFScoreEdge>>,
    Fragmentable {
  node: <T = CounterStrikeFScoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFixture {
  count: Int;
}

export interface AggregateFixturePromise
  extends Promise<AggregateFixture>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFixtureSubscription
  extends Promise<AsyncIterator<AggregateFixture>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface FixtureConnection {
  pageInfo: PageInfo;
  edges: FixtureEdge[];
}

export interface FixtureConnectionPromise
  extends Promise<FixtureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FixtureEdge>>() => T;
  aggregate: <T = AggregateFixturePromise>() => T;
}

export interface FixtureConnectionSubscription
  extends Promise<AsyncIterator<FixtureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FixtureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFixtureSubscription>() => T;
}

export interface EmployeePreviousValues {
  id: ID_Output;
  firstName: String;
  middleName?: String;
  lastName: String;
  profilePictureUrl?: String;
  lmsEmpId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  middleName: () => Promise<String>;
  lastName: () => Promise<String>;
  profilePictureUrl: () => Promise<String>;
  lmsEmpId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  middleName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  profilePictureUrl: () => Promise<AsyncIterator<String>>;
  lmsEmpId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CounterStrikeFScoreConnection {
  pageInfo: PageInfo;
  edges: CounterStrikeFScoreEdge[];
}

export interface CounterStrikeFScoreConnectionPromise
  extends Promise<CounterStrikeFScoreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CounterStrikeFScoreEdge>>() => T;
  aggregate: <T = AggregateCounterStrikeFScorePromise>() => T;
}

export interface CounterStrikeFScoreConnectionSubscription
  extends Promise<AsyncIterator<CounterStrikeFScoreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CounterStrikeFScoreEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCounterStrikeFScoreSubscription>() => T;
}

export interface AggregateDotaScoreActivity {
  count: Int;
}

export interface AggregateDotaScoreActivityPromise
  extends Promise<AggregateDotaScoreActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDotaScoreActivitySubscription
  extends Promise<AsyncIterator<AggregateDotaScoreActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FixtureSubscriptionPayload {
  mutation: MutationType;
  node: Fixture;
  updatedFields: String[];
  previousValues: FixturePreviousValues;
}

export interface FixtureSubscriptionPayloadPromise
  extends Promise<FixtureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FixturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FixturePreviousValuesPromise>() => T;
}

export interface FixtureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FixtureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FixtureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FixturePreviousValuesSubscription>() => T;
}

export interface DotaScoreActivityConnection {
  pageInfo: PageInfo;
  edges: DotaScoreActivityEdge[];
}

export interface DotaScoreActivityConnectionPromise
  extends Promise<DotaScoreActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DotaScoreActivityEdge>>() => T;
  aggregate: <T = AggregateDotaScoreActivityPromise>() => T;
}

export interface DotaScoreActivityConnectionSubscription
  extends Promise<AsyncIterator<DotaScoreActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DotaScoreActivityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDotaScoreActivitySubscription>() => T;
}

export interface FixturePreviousValues {
  id: ID_Output;
  dateTime?: DateTimeOutput;
  images: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FixturePreviousValuesPromise
  extends Promise<FixturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dateTime: () => Promise<DateTimeOutput>;
  images: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FixturePreviousValuesSubscription
  extends Promise<AsyncIterator<FixturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  images: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateDotaScore {
  count: Int;
}

export interface AggregateDotaScorePromise
  extends Promise<AggregateDotaScore>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDotaScoreSubscription
  extends Promise<AsyncIterator<AggregateDotaScore>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CounterStrikeFScore {
  id: ID_Output;
  homeTeamScore?: Int;
  awayTeamScore?: Int;
  setsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CounterStrikeFScorePromise
  extends Promise<CounterStrikeFScore>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  setsCount: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CounterStrikeFScoreSubscription
  extends Promise<AsyncIterator<CounterStrikeFScore>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  setsCount: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CounterStrikeFScoreNullablePromise
  extends Promise<CounterStrikeFScore | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  setsCount: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DotaScoreConnection {
  pageInfo: PageInfo;
  edges: DotaScoreEdge[];
}

export interface DotaScoreConnectionPromise
  extends Promise<DotaScoreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DotaScoreEdge>>() => T;
  aggregate: <T = AggregateDotaScorePromise>() => T;
}

export interface DotaScoreConnectionSubscription
  extends Promise<AsyncIterator<DotaScoreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DotaScoreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDotaScoreSubscription>() => T;
}

export interface FootballScoreSubscriptionPayload {
  mutation: MutationType;
  node: FootballScore;
  updatedFields: String[];
  previousValues: FootballScorePreviousValues;
}

export interface FootballScoreSubscriptionPayloadPromise
  extends Promise<FootballScoreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FootballScorePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FootballScorePreviousValuesPromise>() => T;
}

export interface FootballScoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FootballScoreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FootballScoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FootballScorePreviousValuesSubscription>() => T;
}

export interface UserAccountTokenEdge {
  node: UserAccountToken;
  cursor: String;
}

export interface UserAccountTokenEdgePromise
  extends Promise<UserAccountTokenEdge>,
    Fragmentable {
  node: <T = UserAccountTokenPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserAccountTokenEdgeSubscription
  extends Promise<AsyncIterator<UserAccountTokenEdge>>,
    Fragmentable {
  node: <T = UserAccountTokenSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FootballScorePreviousValues {
  id: ID_Output;
  homeTeamFTScore?: Int;
  awayTeamFTScore?: Int;
  homeTeamAetScore?: Int;
  awayTeamAetScore?: Int;
  homeTeamPenaltyScore?: Int;
  awayTeamPenaltyScore?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FootballScorePreviousValuesPromise
  extends Promise<FootballScorePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  homeTeamFTScore: () => Promise<Int>;
  awayTeamFTScore: () => Promise<Int>;
  homeTeamAetScore: () => Promise<Int>;
  awayTeamAetScore: () => Promise<Int>;
  homeTeamPenaltyScore: () => Promise<Int>;
  awayTeamPenaltyScore: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FootballScorePreviousValuesSubscription
  extends Promise<AsyncIterator<FootballScorePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  homeTeamFTScore: () => Promise<AsyncIterator<Int>>;
  awayTeamFTScore: () => Promise<AsyncIterator<Int>>;
  homeTeamAetScore: () => Promise<AsyncIterator<Int>>;
  awayTeamAetScore: () => Promise<AsyncIterator<Int>>;
  homeTeamPenaltyScore: () => Promise<AsyncIterator<Int>>;
  awayTeamPenaltyScore: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Fixture {
  id: ID_Output;
  dateTime?: DateTimeOutput;
  images: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FixturePromise extends Promise<Fixture>, Fragmentable {
  id: () => Promise<ID_Output>;
  subTournament: <T = SubTournamentPromise>() => T;
  status: <T = StatusPromise>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  homeTeam: <T = TeamPromise>() => T;
  awayTeam: <T = TeamPromise>() => T;
  round: <T = RoundPromise>() => T;
  homeTeamParentFixture: <T = FixturePromise>() => T;
  awayTeamParentFixture: <T = FixturePromise>() => T;
  images: () => Promise<String[]>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FixtureSubscription
  extends Promise<AsyncIterator<Fixture>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subTournament: <T = SubTournamentSubscription>() => T;
  status: <T = StatusSubscription>() => T;
  dateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  homeTeam: <T = TeamSubscription>() => T;
  awayTeam: <T = TeamSubscription>() => T;
  round: <T = RoundSubscription>() => T;
  homeTeamParentFixture: <T = FixtureSubscription>() => T;
  awayTeamParentFixture: <T = FixtureSubscription>() => T;
  images: () => Promise<AsyncIterator<String[]>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FixtureNullablePromise
  extends Promise<Fixture | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subTournament: <T = SubTournamentPromise>() => T;
  status: <T = StatusPromise>() => T;
  dateTime: () => Promise<DateTimeOutput>;
  homeTeam: <T = TeamPromise>() => T;
  awayTeam: <T = TeamPromise>() => T;
  round: <T = RoundPromise>() => T;
  homeTeamParentFixture: <T = FixturePromise>() => T;
  awayTeamParentFixture: <T = FixturePromise>() => T;
  images: () => Promise<String[]>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateChessScore {
  count: Int;
}

export interface AggregateChessScorePromise
  extends Promise<AggregateChessScore>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChessScoreSubscription
  extends Promise<AsyncIterator<AggregateChessScore>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserAccountConnection {
  pageInfo: PageInfo;
  edges: UserAccountEdge[];
}

export interface UserAccountConnectionPromise
  extends Promise<UserAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserAccountEdge>>() => T;
  aggregate: <T = AggregateUserAccountPromise>() => T;
}

export interface UserAccountConnectionSubscription
  extends Promise<AsyncIterator<UserAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserAccountSubscription>() => T;
}

export interface FootballScoreActivitySubscriptionPayload {
  mutation: MutationType;
  node: FootballScoreActivity;
  updatedFields: String[];
  previousValues: FootballScoreActivityPreviousValues;
}

export interface FootballScoreActivitySubscriptionPayloadPromise
  extends Promise<FootballScoreActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FootballScoreActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FootballScoreActivityPreviousValuesPromise>() => T;
}

export interface FootballScoreActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FootballScoreActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FootballScoreActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FootballScoreActivityPreviousValuesSubscription>() => T;
}

export interface TournamentConnection {
  pageInfo: PageInfo;
  edges: TournamentEdge[];
}

export interface TournamentConnectionPromise
  extends Promise<TournamentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TournamentEdge>>() => T;
  aggregate: <T = AggregateTournamentPromise>() => T;
}

export interface TournamentConnectionSubscription
  extends Promise<AsyncIterator<TournamentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TournamentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTournamentSubscription>() => T;
}

export interface FootballScoreActivityPreviousValues {
  id: ID_Output;
  activityType: FootballActivityType;
  activityTime?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FootballScoreActivityPreviousValuesPromise
  extends Promise<FootballScoreActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  activityType: () => Promise<FootballActivityType>;
  activityTime: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FootballScoreActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<FootballScoreActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  activityType: () => Promise<AsyncIterator<FootballActivityType>>;
  activityTime: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TeamPlayerConnection {
  pageInfo: PageInfo;
  edges: TeamPlayerEdge[];
}

export interface TeamPlayerConnectionPromise
  extends Promise<TeamPlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamPlayerEdge>>() => T;
  aggregate: <T = AggregateTeamPlayerPromise>() => T;
}

export interface TeamPlayerConnectionSubscription
  extends Promise<AsyncIterator<TeamPlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamPlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamPlayerSubscription>() => T;
}

export interface ChessScoreEdge {
  node: ChessScore;
  cursor: String;
}

export interface ChessScoreEdgePromise
  extends Promise<ChessScoreEdge>,
    Fragmentable {
  node: <T = ChessScorePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChessScoreEdgeSubscription
  extends Promise<AsyncIterator<ChessScoreEdge>>,
    Fragmentable {
  node: <T = ChessScoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface TableTennisScoreActivityConnection {
  pageInfo: PageInfo;
  edges: TableTennisScoreActivityEdge[];
}

export interface TableTennisScoreActivityConnectionPromise
  extends Promise<TableTennisScoreActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TableTennisScoreActivityEdge>>() => T;
  aggregate: <T = AggregateTableTennisScoreActivityPromise>() => T;
}

export interface TableTennisScoreActivityConnectionSubscription
  extends Promise<AsyncIterator<TableTennisScoreActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TableTennisScoreActivityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTableTennisScoreActivitySubscription>() => T;
}

export interface GamePreviousValues {
  id: ID_Output;
  name: String;
  shortName: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TableTennisScoreEdge {
  node: TableTennisScore;
  cursor: String;
}

export interface TableTennisScoreEdgePromise
  extends Promise<TableTennisScoreEdge>,
    Fragmentable {
  node: <T = TableTennisScorePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TableTennisScoreEdgeSubscription
  extends Promise<AsyncIterator<TableTennisScoreEdge>>,
    Fragmentable {
  node: <T = TableTennisScoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChessScoreConnection {
  pageInfo: PageInfo;
  edges: ChessScoreEdge[];
}

export interface ChessScoreConnectionPromise
  extends Promise<ChessScoreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChessScoreEdge>>() => T;
  aggregate: <T = AggregateChessScorePromise>() => T;
}

export interface ChessScoreConnectionSubscription
  extends Promise<AsyncIterator<ChessScoreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChessScoreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChessScoreSubscription>() => T;
}

export interface SubTournamentEdge {
  node: SubTournament;
  cursor: String;
}

export interface SubTournamentEdgePromise
  extends Promise<SubTournamentEdge>,
    Fragmentable {
  node: <T = SubTournamentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubTournamentEdgeSubscription
  extends Promise<AsyncIterator<SubTournamentEdge>>,
    Fragmentable {
  node: <T = SubTournamentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoundSubscriptionPayload {
  mutation: MutationType;
  node: Round;
  updatedFields: String[];
  previousValues: RoundPreviousValues;
}

export interface RoundSubscriptionPayloadPromise
  extends Promise<RoundSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoundPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoundPreviousValuesPromise>() => T;
}

export interface RoundSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoundSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoundSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoundPreviousValuesSubscription>() => T;
}

export interface StatusEdge {
  node: Status;
  cursor: String;
}

export interface StatusEdgePromise extends Promise<StatusEdge>, Fragmentable {
  node: <T = StatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StatusEdgeSubscription
  extends Promise<AsyncIterator<StatusEdge>>,
    Fragmentable {
  node: <T = StatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoundPreviousValues {
  id: ID_Output;
  name: String;
  shortName: String;
  sortOrder: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RoundPreviousValuesPromise
  extends Promise<RoundPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  sortOrder: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RoundPreviousValuesSubscription
  extends Promise<AsyncIterator<RoundPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  sortOrder: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RoundEdge {
  node: Round;
  cursor: String;
}

export interface RoundEdgePromise extends Promise<RoundEdge>, Fragmentable {
  node: <T = RoundPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoundEdgeSubscription
  extends Promise<AsyncIterator<RoundEdge>>,
    Fragmentable {
  node: <T = RoundSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChessScore {
  id: ID_Output;
  winningMethod?: ChessWinningMethod;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ChessScorePromise extends Promise<ChessScore>, Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  winnerTeam: <T = TeamPromise>() => T;
  winningMethod: () => Promise<ChessWinningMethod>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChessScoreSubscription
  extends Promise<AsyncIterator<ChessScore>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  winnerTeam: <T = TeamSubscription>() => T;
  winningMethod: () => Promise<AsyncIterator<ChessWinningMethod>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChessScoreNullablePromise
  extends Promise<ChessScore | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  winnerTeam: <T = TeamPromise>() => T;
  winningMethod: () => Promise<ChessWinningMethod>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StatusSubscriptionPayload {
  mutation: MutationType;
  node: Status;
  updatedFields: String[];
  previousValues: StatusPreviousValues;
}

export interface StatusSubscriptionPayloadPromise
  extends Promise<StatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StatusPreviousValuesPromise>() => T;
}

export interface StatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StatusPreviousValuesSubscription>() => T;
}

export interface FootballScoreActivityEdge {
  node: FootballScoreActivity;
  cursor: String;
}

export interface FootballScoreActivityEdgePromise
  extends Promise<FootballScoreActivityEdge>,
    Fragmentable {
  node: <T = FootballScoreActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FootballScoreActivityEdgeSubscription
  extends Promise<AsyncIterator<FootballScoreActivityEdge>>,
    Fragmentable {
  node: <T = FootballScoreActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StatusPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StatusPreviousValuesPromise
  extends Promise<StatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StatusPreviousValuesSubscription
  extends Promise<AsyncIterator<StatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FootballScoreActivity {
  id: ID_Output;
  activityType: FootballActivityType;
  activityTime?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FootballScoreActivityPromise
  extends Promise<FootballScoreActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  teamPlayer: <T = TeamPlayerPromise>() => T;
  activityType: () => Promise<FootballActivityType>;
  assistedBy: <T = TeamPlayerPromise>() => T;
  activityTime: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FootballScoreActivitySubscription
  extends Promise<AsyncIterator<FootballScoreActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  teamPlayer: <T = TeamPlayerSubscription>() => T;
  activityType: () => Promise<AsyncIterator<FootballActivityType>>;
  assistedBy: <T = TeamPlayerSubscription>() => T;
  activityTime: () => Promise<AsyncIterator<String>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FootballScoreActivityNullablePromise
  extends Promise<FootballScoreActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  teamPlayer: <T = TeamPlayerPromise>() => T;
  activityType: () => Promise<FootballActivityType>;
  assistedBy: <T = TeamPlayerPromise>() => T;
  activityTime: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FootballScore {
  id: ID_Output;
  homeTeamFTScore?: Int;
  awayTeamFTScore?: Int;
  homeTeamAetScore?: Int;
  awayTeamAetScore?: Int;
  homeTeamPenaltyScore?: Int;
  awayTeamPenaltyScore?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FootballScorePromise
  extends Promise<FootballScore>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamFTScore: () => Promise<Int>;
  awayTeamFTScore: () => Promise<Int>;
  homeTeamAetScore: () => Promise<Int>;
  awayTeamAetScore: () => Promise<Int>;
  homeTeamPenaltyScore: () => Promise<Int>;
  awayTeamPenaltyScore: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FootballScoreSubscription
  extends Promise<AsyncIterator<FootballScore>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  homeTeamFTScore: () => Promise<AsyncIterator<Int>>;
  awayTeamFTScore: () => Promise<AsyncIterator<Int>>;
  homeTeamAetScore: () => Promise<AsyncIterator<Int>>;
  awayTeamAetScore: () => Promise<AsyncIterator<Int>>;
  homeTeamPenaltyScore: () => Promise<AsyncIterator<Int>>;
  awayTeamPenaltyScore: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FootballScoreNullablePromise
  extends Promise<FootballScore | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeamFTScore: () => Promise<Int>;
  awayTeamFTScore: () => Promise<Int>;
  homeTeamAetScore: () => Promise<Int>;
  awayTeamAetScore: () => Promise<Int>;
  homeTeamPenaltyScore: () => Promise<Int>;
  awayTeamPenaltyScore: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubTournamentSubscriptionPayload {
  mutation: MutationType;
  node: SubTournament;
  updatedFields: String[];
  previousValues: SubTournamentPreviousValues;
}

export interface SubTournamentSubscriptionPayloadPromise
  extends Promise<SubTournamentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubTournamentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubTournamentPreviousValuesPromise>() => T;
}

export interface SubTournamentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubTournamentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubTournamentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubTournamentPreviousValuesSubscription>() => T;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubTournamentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubTournamentPreviousValuesPromise
  extends Promise<SubTournamentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubTournamentPreviousValuesSubscription
  extends Promise<AsyncIterator<SubTournamentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DotaScoreActivityEdge {
  node: DotaScoreActivity;
  cursor: String;
}

export interface DotaScoreActivityEdgePromise
  extends Promise<DotaScoreActivityEdge>,
    Fragmentable {
  node: <T = DotaScoreActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DotaScoreActivityEdgeSubscription
  extends Promise<AsyncIterator<DotaScoreActivityEdge>>,
    Fragmentable {
  node: <T = DotaScoreActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DotaScoreEdge {
  node: DotaScore;
  cursor: String;
}

export interface DotaScoreEdgePromise
  extends Promise<DotaScoreEdge>,
    Fragmentable {
  node: <T = DotaScorePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DotaScoreEdgeSubscription
  extends Promise<AsyncIterator<DotaScoreEdge>>,
    Fragmentable {
  node: <T = DotaScoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubTournamentPlayerSubscriptionPayload {
  mutation: MutationType;
  node: SubTournamentPlayer;
  updatedFields: String[];
  previousValues: SubTournamentPlayerPreviousValues;
}

export interface SubTournamentPlayerSubscriptionPayloadPromise
  extends Promise<SubTournamentPlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubTournamentPlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubTournamentPlayerPreviousValuesPromise>() => T;
}

export interface SubTournamentPlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubTournamentPlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubTournamentPlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubTournamentPlayerPreviousValuesSubscription>() => T;
}

export interface UserAccountSubscriptionPayload {
  mutation: MutationType;
  node: UserAccount;
  updatedFields: String[];
  previousValues: UserAccountPreviousValues;
}

export interface UserAccountSubscriptionPayloadPromise
  extends Promise<UserAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserAccountPreviousValuesPromise>() => T;
}

export interface UserAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserAccountPreviousValuesSubscription>() => T;
}

export interface SubTournamentPlayerPreviousValues {
  id: ID_Output;
  position?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubTournamentPlayerPreviousValuesPromise
  extends Promise<SubTournamentPlayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  position: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubTournamentPlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<SubTournamentPlayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  position: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTournament {
  count: Int;
}

export interface AggregateTournamentPromise
  extends Promise<AggregateTournament>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTournamentSubscription
  extends Promise<AsyncIterator<AggregateTournament>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TableTennisScoreSubscriptionPayload {
  mutation: MutationType;
  node: TableTennisScore;
  updatedFields: String[];
  previousValues: TableTennisScorePreviousValues;
}

export interface TableTennisScoreSubscriptionPayloadPromise
  extends Promise<TableTennisScoreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TableTennisScorePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TableTennisScorePreviousValuesPromise>() => T;
}

export interface TableTennisScoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TableTennisScoreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TableTennisScoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TableTennisScorePreviousValuesSubscription>() => T;
}

export interface TableTennisScoreActivity {
  id: ID_Output;
  set: Int;
  homeTeamPoints: Int;
  awayTeamPoints: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TableTennisScoreActivityPromise
  extends Promise<TableTennisScoreActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  set: () => Promise<Int>;
  homeTeamPoints: () => Promise<Int>;
  awayTeamPoints: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScoreActivitySubscription
  extends Promise<AsyncIterator<TableTennisScoreActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  set: () => Promise<AsyncIterator<Int>>;
  homeTeamPoints: () => Promise<AsyncIterator<Int>>;
  awayTeamPoints: () => Promise<AsyncIterator<Int>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TableTennisScoreActivityNullablePromise
  extends Promise<TableTennisScoreActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  set: () => Promise<Int>;
  homeTeamPoints: () => Promise<Int>;
  awayTeamPoints: () => Promise<Int>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScorePreviousValues {
  id: ID_Output;
  homeTeamScore?: Int;
  awayTeamScore?: Int;
  setsCount: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TableTennisScorePreviousValuesPromise
  extends Promise<TableTennisScorePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  homeTeamScore: () => Promise<Int>;
  awayTeamScore: () => Promise<Int>;
  setsCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScorePreviousValuesSubscription
  extends Promise<AsyncIterator<TableTennisScorePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  homeTeamScore: () => Promise<AsyncIterator<Int>>;
  awayTeamScore: () => Promise<AsyncIterator<Int>>;
  setsCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAccountTokenSubscriptionPayload {
  mutation: MutationType;
  node: UserAccountToken;
  updatedFields: String[];
  previousValues: UserAccountTokenPreviousValues;
}

export interface UserAccountTokenSubscriptionPayloadPromise
  extends Promise<UserAccountTokenSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserAccountTokenPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserAccountTokenPreviousValuesPromise>() => T;
}

export interface UserAccountTokenSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserAccountTokenSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserAccountTokenSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserAccountTokenPreviousValuesSubscription>() => T;
}

export interface AggregateCarromBoardScoreActivity {
  count: Int;
}

export interface AggregateCarromBoardScoreActivityPromise
  extends Promise<AggregateCarromBoardScoreActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCarromBoardScoreActivitySubscription
  extends Promise<AsyncIterator<AggregateCarromBoardScoreActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Category {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScoreActivitySubscriptionPayload {
  mutation: MutationType;
  node: TableTennisScoreActivity;
  updatedFields: String[];
  previousValues: TableTennisScoreActivityPreviousValues;
}

export interface TableTennisScoreActivitySubscriptionPayloadPromise
  extends Promise<TableTennisScoreActivitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TableTennisScoreActivityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TableTennisScoreActivityPreviousValuesPromise>() => T;
}

export interface TableTennisScoreActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TableTennisScoreActivitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TableTennisScoreActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = TableTennisScoreActivityPreviousValuesSubscription
  >() => T;
}

export interface Team {
  id: ID_Output;
  name: String;
  logoImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  logoImage: () => Promise<String>;
  subTournament: <T = SubTournamentPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  logoImage: () => Promise<AsyncIterator<String>>;
  subTournament: <T = SubTournamentSubscription>() => T;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TeamNullablePromise
  extends Promise<Team | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  logoImage: () => Promise<String>;
  subTournament: <T = SubTournamentPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScoreActivityPreviousValues {
  id: ID_Output;
  set: Int;
  homeTeamPoints: Int;
  awayTeamPoints: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TableTennisScoreActivityPreviousValuesPromise
  extends Promise<TableTennisScoreActivityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  set: () => Promise<Int>;
  homeTeamPoints: () => Promise<Int>;
  awayTeamPoints: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TableTennisScoreActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<TableTennisScoreActivityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  set: () => Promise<AsyncIterator<Int>>;
  homeTeamPoints: () => Promise<AsyncIterator<Int>>;
  awayTeamPoints: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FixtureEdge {
  node: Fixture;
  cursor: String;
}

export interface FixtureEdgePromise extends Promise<FixtureEdge>, Fragmentable {
  node: <T = FixturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FixtureEdgeSubscription
  extends Promise<AsyncIterator<FixtureEdge>>,
    Fragmentable {
  node: <T = FixtureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CarromBoardScoreActivityEdge {
  node: CarromBoardScoreActivity;
  cursor: String;
}

export interface CarromBoardScoreActivityEdgePromise
  extends Promise<CarromBoardScoreActivityEdge>,
    Fragmentable {
  node: <T = CarromBoardScoreActivityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CarromBoardScoreActivityEdgeSubscription
  extends Promise<AsyncIterator<CarromBoardScoreActivityEdge>>,
    Fragmentable {
  node: <T = CarromBoardScoreActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DotaScoreActivity {
  id: ID_Output;
  set: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DotaScoreActivityPromise
  extends Promise<DotaScoreActivity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  set: () => Promise<Int>;
  winnerTeam: <T = TeamPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DotaScoreActivitySubscription
  extends Promise<AsyncIterator<DotaScoreActivity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  set: () => Promise<AsyncIterator<Int>>;
  winnerTeam: <T = TeamSubscription>() => T;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DotaScoreActivityNullablePromise
  extends Promise<DotaScoreActivity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  set: () => Promise<Int>;
  winnerTeam: <T = TeamPromise>() => T;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface AggregateUserAccount {
  count: Int;
}

export interface AggregateUserAccountPromise
  extends Promise<AggregateUserAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserAccountSubscription
  extends Promise<AsyncIterator<AggregateUserAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamPreviousValues {
  id: ID_Output;
  name: String;
  logoImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  logoImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  logoImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTableTennisScoreActivity {
  count: Int;
}

export interface AggregateTableTennisScoreActivityPromise
  extends Promise<AggregateTableTennisScoreActivity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTableTennisScoreActivitySubscription
  extends Promise<AsyncIterator<AggregateTableTennisScoreActivity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CarromBoardScoreActivityConnection {
  pageInfo: PageInfo;
  edges: CarromBoardScoreActivityEdge[];
}

export interface CarromBoardScoreActivityConnectionPromise
  extends Promise<CarromBoardScoreActivityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CarromBoardScoreActivityEdge>>() => T;
  aggregate: <T = AggregateCarromBoardScoreActivityPromise>() => T;
}

export interface CarromBoardScoreActivityConnectionSubscription
  extends Promise<AsyncIterator<CarromBoardScoreActivityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CarromBoardScoreActivityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCarromBoardScoreActivitySubscription>() => T;
}

export interface AggregateCarromBoardScore {
  count: Int;
}

export interface AggregateCarromBoardScorePromise
  extends Promise<AggregateCarromBoardScore>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCarromBoardScoreSubscription
  extends Promise<AsyncIterator<AggregateCarromBoardScore>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamPlayerSubscriptionPayload {
  mutation: MutationType;
  node: TeamPlayer;
  updatedFields: String[];
  previousValues: TeamPlayerPreviousValues;
}

export interface TeamPlayerSubscriptionPayloadPromise
  extends Promise<TeamPlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPlayerPreviousValuesPromise>() => T;
}

export interface TeamPlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamPlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamPlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPlayerPreviousValuesSubscription>() => T;
}

export interface FootballScoreEdge {
  node: FootballScore;
  cursor: String;
}

export interface FootballScoreEdgePromise
  extends Promise<FootballScoreEdge>,
    Fragmentable {
  node: <T = FootballScorePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FootballScoreEdgeSubscription
  extends Promise<AsyncIterator<FootballScoreEdge>>,
    Fragmentable {
  node: <T = FootballScoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserAccountPreviousValues {
  id: ID_Output;
  isActive: Boolean;
  password: String;
  userRole: UserRole;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAccountPreviousValuesPromise
  extends Promise<UserAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  password: () => Promise<String>;
  userRole: () => Promise<UserRole>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<UserAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  userRole: () => Promise<AsyncIterator<UserRole>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TournamentPreviousValues {
  id: ID_Output;
  season: String;
  startDate: DateTimeOutput;
  finishDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TournamentPreviousValuesPromise
  extends Promise<TournamentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  season: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  finishDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TournamentPreviousValuesSubscription
  extends Promise<AsyncIterator<TournamentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  season: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  finishDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TournamentSubscriptionPayload {
  mutation: MutationType;
  node: Tournament;
  updatedFields: String[];
  previousValues: TournamentPreviousValues;
}

export interface TournamentSubscriptionPayloadPromise
  extends Promise<TournamentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TournamentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TournamentPreviousValuesPromise>() => T;
}

export interface TournamentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TournamentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TournamentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TournamentPreviousValuesSubscription>() => T;
}

export interface CarromBoardScoreConnection {
  pageInfo: PageInfo;
  edges: CarromBoardScoreEdge[];
}

export interface CarromBoardScoreConnectionPromise
  extends Promise<CarromBoardScoreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CarromBoardScoreEdge>>() => T;
  aggregate: <T = AggregateCarromBoardScorePromise>() => T;
}

export interface CarromBoardScoreConnectionSubscription
  extends Promise<AsyncIterator<CarromBoardScoreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CarromBoardScoreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCarromBoardScoreSubscription>() => T;
}

export interface TeamPlayerPreviousValues {
  id: ID_Output;
  isCaptain: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TeamPlayerPreviousValuesPromise
  extends Promise<TeamPlayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isCaptain: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamPlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPlayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isCaptain: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTeamPlayer {
  count: Int;
}

export interface AggregateTeamPlayerPromise
  extends Promise<AggregateTeamPlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamPlayerSubscription
  extends Promise<AsyncIterator<AggregateTeamPlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface Status {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StatusPromise extends Promise<Status>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StatusSubscription
  extends Promise<AsyncIterator<Status>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedBy: <T = UserAccountSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StatusNullablePromise
  extends Promise<Status | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedBy: <T = UserAccountPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Employee {
  id: ID_Output;
  firstName: String;
  middleName?: String;
  lastName: String;
  profilePictureUrl?: String;
  lmsEmpId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  middleName: () => Promise<String>;
  lastName: () => Promise<String>;
  profilePictureUrl: () => Promise<String>;
  lmsEmpId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  middleName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  profilePictureUrl: () => Promise<AsyncIterator<String>>;
  lmsEmpId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeeNullablePromise
  extends Promise<Employee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  middleName: () => Promise<String>;
  lastName: () => Promise<String>;
  profilePictureUrl: () => Promise<String>;
  lmsEmpId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "UserAccount",
    embedded: false
  },
  {
    name: "UserAccountToken",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "Tournament",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "SubTournament",
    embedded: false
  },
  {
    name: "SubTournamentPlayer",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "TeamPlayer",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "Round",
    embedded: false
  },
  {
    name: "Fixture",
    embedded: false
  },
  {
    name: "FootballScore",
    embedded: false
  },
  {
    name: "FootballActivityType",
    embedded: false
  },
  {
    name: "FootballScoreActivity",
    embedded: false
  },
  {
    name: "ChessWinningMethod",
    embedded: false
  },
  {
    name: "ChessScore",
    embedded: false
  },
  {
    name: "CarromBoardScore",
    embedded: false
  },
  {
    name: "CarromBoardScoreActivity",
    embedded: false
  },
  {
    name: "TableTennisScore",
    embedded: false
  },
  {
    name: "TableTennisScoreActivity",
    embedded: false
  },
  {
    name: "CounterStrikeFScore",
    embedded: false
  },
  {
    name: "CounterStrikeScoreSet",
    embedded: false
  },
  {
    name: "CounterStrikeScoreSetActivity",
    embedded: false
  },
  {
    name: "DotaScore",
    embedded: false
  },
  {
    name: "DotaScoreActivity",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`,
  secret: `${process.env["PRISMA_SERVICE_SECRET"]}`
});
export const prisma = new Prisma();
